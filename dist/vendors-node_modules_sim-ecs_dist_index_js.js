"use strict";
(self["webpackChunkcitylights"] = self["webpackChunkcitylights"] || []).push([["vendors-node_modules_sim-ecs_dist_index_js"],{

/***/ "./node_modules/sim-ecs/dist/commands/command-entity-builder.js":
/*!**********************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/commands/command-entity-builder.js ***!
  \**********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandEntityBuilder = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
const entity_1 = __webpack_require__(/*! ../entity */ "./node_modules/sim-ecs/dist/entity.js");
tslib_1.__exportStar(__webpack_require__(/*! ./command-entity-builder.spec */ "./node_modules/sim-ecs/dist/commands/command-entity-builder.spec.js"), exports);
class CommandEntityBuilder {
    constructor(commands) {
        this.commands = commands;
        this.entity = new entity_1.Entity();
    }
    build() {
        this.commands.aggregator.addCommand(() => this.commands.world.addEntity(this.entity));
    }
    with(component, ...args) {
        this.entity.addComponent(this.asComponent(component));
        return this;
    }
    withAll(...components) {
        let component;
        for (component of components) {
            this.with(component);
        }
        return this;
    }
    asComponent(component, ...args) {
        return typeof component === 'object'
            ? component
            : new (component.prototype.constructor.bind(component, ...Array.from(arguments).slice(1)))();
    }
}
exports.CommandEntityBuilder = CommandEntityBuilder;
//# sourceMappingURL=command-entity-builder.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/commands/command-entity-builder.spec.js":
/*!***************************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/commands/command-entity-builder.spec.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=command-entity-builder.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/commands/commands-aggregator.js":
/*!*******************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/commands/commands-aggregator.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CommandsAggregator = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./commands-aggregator.spec */ "./node_modules/sim-ecs/dist/commands/commands-aggregator.spec.js"), exports);
class CommandsAggregator {
    constructor(world) {
        this.world = world;
        this.commands = [];
        this.doMaintain = false;
    }
    addCommand(command) {
        this.commands.push(command);
    }
    async executeAll() {
        for (let command = this.commands.shift(); !!command; command = this.commands.shift()) {
            await command();
        }
        if (this.doMaintain) {
            this.world.maintain();
        }
    }
    triggerMaintain() {
        this.doMaintain = true;
    }
}
exports.CommandsAggregator = CommandsAggregator;
//# sourceMappingURL=commands-aggregator.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/commands/commands-aggregator.spec.js":
/*!************************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/commands/commands-aggregator.spec.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=commands-aggregator.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/commands/commands.js":
/*!********************************************************!*\
  !*** ./node_modules/sim-ecs/dist/commands/commands.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Commands = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
const command_entity_builder_1 = __webpack_require__(/*! ./command-entity-builder */ "./node_modules/sim-ecs/dist/commands/command-entity-builder.js");
tslib_1.__exportStar(__webpack_require__(/*! ./commands.spec */ "./node_modules/sim-ecs/dist/commands/commands.spec.js"), exports);
class Commands {
    constructor(world, aggregator) {
        this.world = world;
        this.aggregator = aggregator;
    }
    addEntity(entity) {
        this.aggregator.addCommand(() => this.world.addEntity(entity));
    }
    addResource(obj, ...args) {
        let type;
        let instance;
        if (typeof obj === 'object') {
            type = obj.constructor;
            instance = obj;
        }
        else {
            type = obj;
            instance = new (obj.prototype.constructor.bind(obj, ...Array.from(arguments).slice(1)))();
        }
        if (this.world.resources.has(type)) {
            throw new Error(`Resource with name "${type.name}" already exists!`);
        }
        this.aggregator.addCommand(() => {
            if (this.world.resources.has(type)) {
                throw new Error(`Resource with name "${type.name}" already exists!`);
            }
            this.world.resources.set(type, instance);
        });
        return instance;
    }
    buildEntity() {
        return new command_entity_builder_1.CommandEntityBuilder(this);
    }
    clearEntities() {
        this.aggregator.addCommand(() => this.world.entities.clear());
    }
    load(prefab, options) {
        const handle = this.world.groups.nextHandle++;
        this.aggregator.addCommand(() => { this.world.load(prefab, options, handle); });
        return handle;
    }
    maintain() {
        this.aggregator.triggerMaintain();
    }
    merge(world) {
        const handle = this.world.groups.nextHandle++;
        this.aggregator.addCommand(() => { this.world.merge(world, handle); });
        return handle;
    }
    popState() {
        this.aggregator.addCommand(() => this.world.popState());
    }
    pushState(NewState) {
        this.aggregator.addCommand(() => this.world.pushState(NewState));
    }
    queueCommand(command) {
        this.aggregator.addCommand(command);
    }
    removeEntity(entity) {
        this.aggregator.addCommand(() => this.world.removeEntity(entity));
    }
    removeResource(type) {
        if (!this.world.resources.has(type)) {
            throw new Error(`Resource with name "${type.name}" does not exists!`);
        }
        this.aggregator.addCommand(() => {
            if (!this.world.resources.has(type)) {
                throw new Error(`Resource with name "${type.name}" does not exists!`);
            }
            this.world.resources.delete(type);
        });
    }
    replaceResource(obj, ...args) {
        let type;
        if (typeof obj === 'object') {
            type = obj.constructor;
        }
        else {
            type = obj;
        }
        if (!this.world.resources.has(type)) {
            throw new Error(`Resource with name "${type.name}" does not exists!`);
        }
        this.aggregator.addCommand(() => {
            if (!this.world.resources.has(type)) {
                throw new Error(`Resource with name "${type.name}" does not exists!`);
            }
            this.world.resources.delete(type);
            this.world.addResource(obj, ...args);
        });
    }
    stopRun() {
        this.aggregator.addCommand(() => this.world.stopRun());
    }
    unloadPrefab(handle) {
        this.aggregator.addCommand(() => this.world.unloadPrefab(handle));
    }
}
exports.Commands = Commands;
//# sourceMappingURL=commands.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/commands/commands.spec.js":
/*!*************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/commands/commands.spec.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=commands.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/ecs.js":
/*!******************************************!*\
  !*** ./node_modules/sim-ecs/dist/ecs.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ECS = void 0;
const world_builder_1 = __webpack_require__(/*! ./world-builder */ "./node_modules/sim-ecs/dist/world-builder.js");
class ECS {
    constructor() {
        this.worlds = new Map();
    }
    buildWorld(name) {
        return new world_builder_1.WorldBuilder(this).addCallback(world => this.worlds.set(world, { name, world }));
    }
    removeWorld(world) {
        this.worlds.delete(world);
    }
}
exports.ECS = ECS;
exports.default = ECS;
//# sourceMappingURL=ecs.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/entity-builder.js":
/*!*****************************************************!*\
  !*** ./node_modules/sim-ecs/dist/entity-builder.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.EntityBuilder = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
const entity_1 = __webpack_require__(/*! ./entity */ "./node_modules/sim-ecs/dist/entity.js");
tslib_1.__exportStar(__webpack_require__(/*! ./entity-builder.spec */ "./node_modules/sim-ecs/dist/entity-builder.spec.js"), exports);
class EntityBuilder {
    constructor() {
        this.entity = new entity_1.Entity();
    }
    build() {
        return this.entity;
    }
    with(component, ...args) {
        this.entity.addComponent(this.asComponent(component));
        return this;
    }
    withAll(...components) {
        let component;
        for (component of components) {
            this.with(component);
        }
        return this;
    }
    asComponent(component, ...args) {
        return typeof component === 'object'
            ? component
            : new (component.prototype.constructor.bind(component, ...Array.from(arguments).slice(1)))();
    }
}
exports.EntityBuilder = EntityBuilder;
//# sourceMappingURL=entity-builder.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/entity-builder.spec.js":
/*!**********************************************************!*\
  !*** ./node_modules/sim-ecs/dist/entity-builder.spec.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=entity-builder.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/entity.js":
/*!*********************************************!*\
  !*** ./node_modules/sim-ecs/dist/entity.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.Entity = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./entity.spec */ "./node_modules/sim-ecs/dist/entity.spec.js"), exports);
class Entity {
    constructor() {
        this.components = new Map();
        this.tags = new Set();
    }
    addComponent(component) {
        if (this.hasComponent(component.constructor)) {
            throw new Error(`Component "${component.constructor.name}" already exists on entity!`);
        }
        this.components.set(component.constructor, component);
        return this;
    }
    addTag(tag) {
        this.tags.add(tag);
        return this;
    }
    getComponent(component) {
        return this.components.get(component);
    }
    getComponents() {
        return this.components.values();
    }
    getTags() {
        return this.tags.values();
    }
    hasComponent(component) {
        return this.components.has(component);
    }
    hasTag(tag) {
        return this.tags.has(tag);
    }
    removeComponent(component) {
        this.components.delete(component.constructor);
        return this;
    }
    removeTag(tag) {
        this.tags.delete(tag);
        return this;
    }
}
exports.Entity = Entity;
//# sourceMappingURL=entity.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/entity.spec.js":
/*!**************************************************!*\
  !*** ./node_modules/sim-ecs/dist/entity.spec.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=entity.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/sim-ecs/dist/index.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./ecs */ "./node_modules/sim-ecs/dist/ecs.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./entity */ "./node_modules/sim-ecs/dist/entity.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./entity-builder */ "./node_modules/sim-ecs/dist/entity-builder.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./query */ "./node_modules/sim-ecs/dist/query.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./serde/serde */ "./node_modules/sim-ecs/dist/serde/serde.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./serde/serial-format */ "./node_modules/sim-ecs/dist/serde/serial-format.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./state */ "./node_modules/sim-ecs/dist/state.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./system */ "./node_modules/sim-ecs/dist/system.js"), exports);
tslib_1.__exportStar(__webpack_require__(/*! ./world */ "./node_modules/sim-ecs/dist/world.js"), exports);
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/pda.js":
/*!******************************************!*\
  !*** ./node_modules/sim-ecs/dist/pda.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.PushDownAutomaton = void 0;
class PushDownAutomaton {
    get state() {
        return this.currentState;
    }
    clear() {
        this.currentState = undefined;
        this.statesTail = undefined;
    }
    pop() {
        var _a;
        if (!this.statesTail)
            return;
        const oldTail = this.statesTail;
        this.statesTail = this.statesTail.prevNode;
        this.currentState = (_a = this.statesTail) === null || _a === void 0 ? void 0 : _a.state;
        return oldTail.state;
    }
    push(State) {
        this.currentState = new State();
        this.statesTail = {
            prevNode: this.statesTail,
            state: this.currentState,
        };
    }
}
exports.PushDownAutomaton = PushDownAutomaton;
//# sourceMappingURL=pda.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/query.js":
/*!********************************************!*\
  !*** ./node_modules/sim-ecs/dist/query.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.WithoutTag = exports.Without = exports.WithTag = exports.With = exports.Write = exports.Read = exports.ReadEntity = exports.Query = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
const query_spec_1 = __webpack_require__(/*! ./query.spec */ "./node_modules/sim-ecs/dist/query.spec.js");
const entity_1 = __webpack_require__(/*! ./entity */ "./node_modules/sim-ecs/dist/entity.js");
tslib_1.__exportStar(__webpack_require__(/*! ./query.spec */ "./node_modules/sim-ecs/dist/query.spec.js"), exports);
// todo: ReadEntity() should also work
class Query {
    constructor(queryDescriptor) {
        this.queryDescriptor = queryDescriptor;
        this.queryResult = new Map();
    }
    get descriptor() {
        return this.queryDescriptor;
    }
    [query_spec_1.addEntitySym](entity) {
        if (this.matchesEntity(entity)) {
            if (Array.isArray(this.queryDescriptor)) {
                this.queryResult.set(entity, entity);
            }
            else {
                this.queryResult.set(entity, this.getDataFromEntity(entity, this.queryDescriptor));
            }
        }
    }
    [query_spec_1.clearEntitiesSym]() {
        this.queryResult.clear();
    }
    [query_spec_1.removeEntitySym](entity) {
        this.queryResult.delete(entity);
    }
    [query_spec_1.setEntitiesSym](entities) {
        let entity;
        this.queryResult.clear();
        for (entity of entities) {
            this[query_spec_1.addEntitySym](entity);
        }
    }
    execute(handler) {
        let data;
        for (data of this.queryResult.values()) {
            handler(data);
        }
    }
    getDataFromEntity(entity, descriptor) {
        const components = {};
        let componentDesc;
        for (componentDesc of Object.entries(descriptor)) {
            if (componentDesc[1][query_spec_1.accessDescSym].type == query_spec_1.EAccess.meta) {
                if (componentDesc[1][query_spec_1.accessDescSym].targetType == query_spec_1.ETargetType.entity) {
                    components[componentDesc[0]] = entity;
                }
            }
            else {
                components[componentDesc[0]] = entity.getComponent(componentDesc[1][query_spec_1.accessDescSym].target);
            }
        }
        return components;
    }
    iter(world) {
        if (world) {
            const data = [];
            // @ts-ignore todo: figure out why the type system errors `this`
            const entities = world.getEntities(this);
            let entity;
            for (entity of entities) {
                data.push(this.getDataFromEntity(entity, this.queryDescriptor));
            }
            return data.values();
        }
        else {
            return this.queryResult.values();
        }
    }
    matchesEntity(entity) {
        if (Array.isArray(this.queryDescriptor)) {
            let componentDesc;
            for (componentDesc of this.queryDescriptor) {
                if (componentDesc[query_spec_1.existenceDescSym].targetType == query_spec_1.ETargetType.tag
                    && entity.hasTag(componentDesc[query_spec_1.existenceDescSym].target) != (componentDesc[query_spec_1.existenceDescSym].type == query_spec_1.EExistence.set)) {
                    return false;
                }
                if (componentDesc[query_spec_1.existenceDescSym].targetType == query_spec_1.ETargetType.component
                    && entity.hasComponent(componentDesc[query_spec_1.existenceDescSym].target) != (componentDesc[query_spec_1.existenceDescSym].type == query_spec_1.EExistence.set)) {
                    return false;
                }
            }
        }
        else {
            let componentDesc;
            for (componentDesc of Object.values(this.queryDescriptor)) {
                if (componentDesc[query_spec_1.accessDescSym].targetType == query_spec_1.ETargetType.tag
                    && !entity.hasTag(componentDesc[query_spec_1.accessDescSym].target)) {
                    return false;
                }
                if (componentDesc[query_spec_1.accessDescSym].targetType == query_spec_1.ETargetType.component
                    && !entity.hasComponent(componentDesc[query_spec_1.accessDescSym].target)) {
                    return false;
                }
            }
        }
        return true;
    }
}
exports.Query = Query;
function ReadEntity() {
    return Object.assign({}, entity_1.Entity, {
        [query_spec_1.accessDescSym]: {
            target: entity_1.Entity,
            targetType: query_spec_1.ETargetType.entity,
            type: query_spec_1.EAccess.meta,
        },
    });
}
exports.ReadEntity = ReadEntity;
function Read(componentPrototype) {
    return Object.assign({}, componentPrototype.prototype, {
        [query_spec_1.accessDescSym]: {
            target: componentPrototype,
            targetType: query_spec_1.ETargetType.component,
            type: query_spec_1.EAccess.read,
        },
    });
}
exports.Read = Read;
function Write(componentPrototype) {
    return Object.assign({}, componentPrototype.prototype, {
        [query_spec_1.accessDescSym]: {
            target: componentPrototype,
            targetType: query_spec_1.ETargetType.component,
            type: query_spec_1.EAccess.write,
        },
    });
}
exports.Write = Write;
function With(componentPrototype) {
    return {
        [query_spec_1.existenceDescSym]: {
            target: componentPrototype,
            targetType: query_spec_1.ETargetType.component,
            type: query_spec_1.EExistence.set,
        }
    };
}
exports.With = With;
function WithTag(tag) {
    return {
        [query_spec_1.accessDescSym]: {
            target: tag,
            targetType: query_spec_1.ETargetType.tag,
            type: query_spec_1.EAccess.meta,
        },
        [query_spec_1.existenceDescSym]: {
            target: tag,
            targetType: query_spec_1.ETargetType.tag,
            type: query_spec_1.EExistence.set,
        }
    };
}
exports.WithTag = WithTag;
function Without(componentPrototype) {
    return {
        [query_spec_1.existenceDescSym]: {
            target: componentPrototype,
            targetType: query_spec_1.ETargetType.component,
            type: query_spec_1.EExistence.unset,
        }
    };
}
exports.Without = Without;
function WithoutTag(tag) {
    return {
        [query_spec_1.existenceDescSym]: {
            target: tag,
            targetType: query_spec_1.ETargetType.tag,
            type: query_spec_1.EExistence.unset,
        }
    };
}
exports.WithoutTag = WithoutTag;
//# sourceMappingURL=query.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/query.spec.js":
/*!*************************************************!*\
  !*** ./node_modules/sim-ecs/dist/query.spec.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.ETargetType = exports.EExistence = exports.EAccess = exports.existenceDescSym = exports.accessDescSym = exports.setEntitiesSym = exports.removeEntitySym = exports.clearEntitiesSym = exports.addEntitySym = void 0;
exports.addEntitySym = Symbol();
exports.clearEntitiesSym = Symbol();
exports.removeEntitySym = Symbol();
exports.setEntitiesSym = Symbol();
exports.accessDescSym = Symbol();
exports.existenceDescSym = Symbol();
var EAccess;
(function (EAccess) {
    EAccess[EAccess["meta"] = 0] = "meta";
    EAccess[EAccess["read"] = 1] = "read";
    EAccess[EAccess["write"] = 2] = "write";
})(EAccess = exports.EAccess || (exports.EAccess = {}));
var EExistence;
(function (EExistence) {
    EExistence[EExistence["set"] = 0] = "set";
    EExistence[EExistence["unset"] = 1] = "unset";
})(EExistence = exports.EExistence || (exports.EExistence = {}));
var ETargetType;
(function (ETargetType) {
    ETargetType[ETargetType["component"] = 0] = "component";
    ETargetType[ETargetType["entity"] = 1] = "entity";
    ETargetType[ETargetType["tag"] = 2] = "tag";
})(ETargetType = exports.ETargetType || (exports.ETargetType = {}));
/*
export interface IQuery<D extends IAccessQueryResult<Object> | TExistenceQueryResult> {
    iter(): IterableIterator<D extends Array<infer T> ? IEntity : { [P in keyof D]: Required<Omit<InstanceType<D[P]>, keyof IAccessDescriptor<Object>>> }>
    matchesEntity(entity: IEntity): boolean
}

export type TQueryProto<D extends IAccessQueryResult<Object> | TExistenceQueryResult> = { new(): IQuery<D> };
*/ 
//# sourceMappingURL=query.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/serde/default-handlers.js":
/*!*************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/serde/default-handlers.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.getDefaultDeserializer = exports.getDefaultSerializer = void 0;
const getDefaultSerializer = function (customSerializer) {
    return (component) => {
        let componentName = typeof component;
        switch (typeof component) {
            case 'number': {
                return component;
            }
            case 'object': {
                if (component == null) {
                    return 'null';
                }
                componentName = component.constructor.name;
                switch (component.constructor.name) {
                    case 'Date':
                        return component.getTime();
                    case 'Array':
                    case 'Object':
                        return JSON.stringify(component.toString());
                    case 'Map':
                    case 'Set':
                        return JSON.stringify(Array.from(component));
                    case 'Number':
                        return component;
                }
                break;
            }
            case "string": {
                return JSON.stringify(component);
            }
        }
        if (!customSerializer) {
            throw new Error(`Missing serializer for "${componentName}"!`);
        }
        return customSerializer(component);
    };
};
exports.getDefaultSerializer = getDefaultSerializer;
const getDefaultDeserializer = function (customDeserializer) {
    return (constructorName, data) => {
        switch (constructorName.toLowerCase()) {
            case 'array': {
                if (!Array.isArray(data)) {
                    throw new Error(`Cannot deserialize Array with data of type ${typeof data}! Array expected!`);
                }
                return data;
            }
            case 'date': {
                if (typeof data != 'number') {
                    throw new Error(`Cannot deserialize Date with data of type ${typeof data}! Number expected!`);
                }
                return new Date(data);
            }
            case 'map': {
                if (!Array.isArray(data)) {
                    throw new Error(`Cannot deserialize Map with data of type ${typeof data}! Array of arrays expected!`);
                }
                return new Map(data);
            }
            case 'number': {
                if (typeof data != 'number') {
                    throw new Error(`Cannot deserialize Number with data of type ${typeof data}! Number expected!`);
                }
                return data;
            }
            case 'object': {
                if (typeof data != 'object') {
                    throw new Error(`Cannot deserialize Object with data of type ${typeof data}! Object expected!`);
                }
                return data;
            }
            case 'set': {
                if (!Array.isArray(data)) {
                    throw new Error(`Cannot deserialize Set with data of type ${typeof data}! Array expected!`);
                }
                return new Set(data);
            }
            case 'string': {
                if (typeof data != 'string') {
                    throw new Error(`Cannot deserialize String with data of type ${typeof data}! String expected!`);
                }
                return data;
            }
        }
        if (!customDeserializer) {
            throw new Error(`Missing deserializer for "${constructorName}"!`);
        }
        return customDeserializer(constructorName, data);
    };
};
exports.getDefaultDeserializer = getDefaultDeserializer;
//# sourceMappingURL=default-handlers.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/serde/serde.js":
/*!**************************************************!*\
  !*** ./node_modules/sim-ecs/dist/serde/serde.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SerDe = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
const serde_spec_1 = __webpack_require__(/*! ./serde.spec */ "./node_modules/sim-ecs/dist/serde/serde.spec.js");
const serial_format_1 = __webpack_require__(/*! ./serial-format */ "./node_modules/sim-ecs/dist/serde/serial-format.js");
const default_handlers_1 = __webpack_require__(/*! ./default-handlers */ "./node_modules/sim-ecs/dist/serde/default-handlers.js");
const entity_1 = __webpack_require__(/*! ../entity */ "./node_modules/sim-ecs/dist/entity.js");
tslib_1.__exportStar(__webpack_require__(/*! ./serde.spec */ "./node_modules/sim-ecs/dist/serde/serde.spec.js"), exports);
class SerDe {
    constructor() {
        this.typeHandlers = new Map();
    }
    deserialize(data, options) {
        var _a, _b;
        const finalOptions = {
            useDefaultHandler: (_a = options === null || options === void 0 ? void 0 : options.useDefaultHandler) !== null && _a !== void 0 ? _a : true,
            useRegisteredHandlers: (_b = options === null || options === void 0 ? void 0 : options.useRegisteredHandlers) !== null && _b !== void 0 ? _b : true,
            fallbackHandler: options === null || options === void 0 ? void 0 : options.fallbackHandler,
        };
        const entities = [];
        let entity;
        let serialComponentData;
        let serialComponentName;
        let serialEntity;
        let tag;
        for (serialEntity of data) {
            entity = new entity_1.Entity();
            for ([serialComponentName, serialComponentData] of Object.entries(serialEntity)) {
                if (finalOptions.useRegisteredHandlers && this.typeHandlers.has(serialComponentName)) {
                    entity.addComponent(this.typeHandlers.get(serialComponentName).deserializer(serialComponentData));
                }
                else if (serialComponentName == serde_spec_1.CTagMarker) {
                    if (!Array.isArray(serialComponentData)) {
                        throw new Error('Expected array of tags for the hash identifier!');
                    }
                    for (tag of serialComponentData) {
                        if (!['string', 'number'].includes(typeof tag)) {
                            throw new Error('Tags must be of type string or number!');
                        }
                        entity.addTag(tag);
                    }
                }
                else if (finalOptions.useDefaultHandler) {
                    entity.addComponent(default_handlers_1.getDefaultDeserializer(finalOptions.fallbackHandler)(serialComponentName, serialComponentData));
                }
            }
            entities.push(entity);
        }
        return {
            entities: entities.values(),
        };
    }
    getRegisteredTypeHandlers() {
        return this.typeHandlers.entries();
    }
    registerTypeHandler(Type, deserializer, serializer) {
        if (this.typeHandlers.has(Type.name)) {
            throw new Error(`The type "${Type.name}" was already registered!`);
        }
        this.typeHandlers.set(Type.name, {
            deserializer,
            serializer,
        });
    }
    serialize(data, options) {
        var _a, _b;
        const finalOptions = {
            useDefaultHandler: (_a = options === null || options === void 0 ? void 0 : options.useDefaultHandler) !== null && _a !== void 0 ? _a : true,
            useRegisteredHandlers: (_b = options === null || options === void 0 ? void 0 : options.useRegisteredHandlers) !== null && _b !== void 0 ? _b : true,
            fallbackHandler: options === null || options === void 0 ? void 0 : options.fallbackHandler,
        };
        const outData = new serial_format_1.SerialFormat();
        let component;
        let entity;
        let serialData;
        let serialEntity;
        let tags;
        for (entity of data.entities) {
            serialEntity = {};
            for (component of entity.getComponents()) {
                if (finalOptions.useRegisteredHandlers && this.typeHandlers.has(component.constructor.name)) {
                    serialData = this.typeHandlers.get(component.constructor.name).serializer(component);
                }
                else if (finalOptions.useDefaultHandler) {
                    serialData = default_handlers_1.getDefaultSerializer(finalOptions.fallbackHandler)(component);
                }
                serialEntity[component.constructor.name] = serialData;
                serialData = undefined;
            }
            {
                tags = Array.from(entity.getTags());
                if (tags.length > 0) {
                    serialEntity[serde_spec_1.CTagMarker] = tags;
                }
            }
            outData.push(serialEntity);
        }
        return outData;
    }
}
exports.SerDe = SerDe;
//# sourceMappingURL=serde.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/serde/serde.spec.js":
/*!*******************************************************!*\
  !*** ./node_modules/sim-ecs/dist/serde/serde.spec.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.CTagMarker = void 0;
exports.CTagMarker = '#Tags';
//# sourceMappingURL=serde.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/serde/serial-format.js":
/*!**********************************************************!*\
  !*** ./node_modules/sim-ecs/dist/serde/serial-format.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.SerialFormat = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./serial-format.spec */ "./node_modules/sim-ecs/dist/serde/serial-format.spec.js"), exports);
class SerialFormat extends Array {
    static fromArray(arr) {
        return new SerialFormat().fromArray(arr);
    }
    static fromJSON(json) {
        return new SerialFormat().fromJSON(json);
    }
    fromArray(arr) {
        Object.assign(this, arr);
        return this;
    }
    fromJSON(json) {
        this.length = 0;
        const newVals = JSON.parse(json);
        if (!Array.isArray(newVals)) {
            throw new Error('Input JSON must be an array!');
        }
        for (const entity of newVals) {
            this.push(entity);
        }
        return this;
    }
    toJSON(indentation) {
        return JSON.stringify(Array.from(this), undefined, indentation);
    }
}
exports.SerialFormat = SerialFormat;
//# sourceMappingURL=serial-format.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/serde/serial-format.spec.js":
/*!***************************************************************!*\
  !*** ./node_modules/sim-ecs/dist/serde/serial-format.spec.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=serial-format.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/state.js":
/*!********************************************!*\
  !*** ./node_modules/sim-ecs/dist/state.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.State = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./state.spec */ "./node_modules/sim-ecs/dist/state.spec.js"), exports);
class State {
    constructor(_systems = []) {
        this._systems = _systems;
    }
    get systems() {
        return this._systems;
    }
    activate(actions) { }
    create(actions) { }
    deactivate(actions) { }
    destroy(actions) { }
}
exports.State = State;
//# sourceMappingURL=state.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/state.spec.js":
/*!*************************************************!*\
  !*** ./node_modules/sim-ecs/dist/state.spec.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=state.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/system.js":
/*!*********************************************!*\
  !*** ./node_modules/sim-ecs/dist/system.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.System = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
tslib_1.__exportStar(__webpack_require__(/*! ./system.spec */ "./node_modules/sim-ecs/dist/system.spec.js"), exports);
class System {
    destroy(actions) { }
    setup(actions) { }
}
exports.System = System;
//# sourceMappingURL=system.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/system.spec.js":
/*!**************************************************!*\
  !*** ./node_modules/sim-ecs/dist/system.spec.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=system.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/world-builder.js":
/*!****************************************************!*\
  !*** ./node_modules/sim-ecs/dist/world-builder.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports._ = exports.WorldBuilder = void 0;
const world_1 = __webpack_require__(/*! ./world */ "./node_modules/sim-ecs/dist/world.js");
const serde_1 = __webpack_require__(/*! ./serde/serde */ "./node_modules/sim-ecs/dist/serde/serde.js");
class WorldBuilder {
    constructor(ecs) {
        this.ecs = ecs;
        this.callbacks = new Set();
        this.serde = new serde_1.SerDe();
        this.systemInfos = new Map();
    }
    addCallback(cb) {
        this.callbacks.add(cb);
        return this;
    }
    build() {
        const world = new world_1.World(this.ecs, new Set(this.systemInfos.values()), this.serde);
        for (const cb of this.callbacks) {
            cb(world);
        }
        return world;
    }
    withSystem(System, dependencies) {
        if (this.systemInfos.has(System)) {
            throw new Error(`The system ${System.constructor.name} is already registered!`);
        }
        this.systemInfos.set(System, {
            system: new System(),
            dependencies: new Set(dependencies),
        });
        return this;
    }
    withComponent(Component, options) {
        var _a, _b, _c, _d;
        this.serde.registerTypeHandler(Component, (_b = (_a = options === null || options === void 0 ? void 0 : options.serDe) === null || _a === void 0 ? void 0 : _a.deserializer) !== null && _b !== void 0 ? _b : dataStructDeserializer.bind(undefined, Component), (_d = (_c = options === null || options === void 0 ? void 0 : options.serDe) === null || _c === void 0 ? void 0 : _c.serializer) !== null && _d !== void 0 ? _d : dataStructSerializer);
        return this;
    }
    withComponents(...Components) {
        for (const Component of Components) {
            this.withComponent(Component);
        }
        return this;
    }
}
exports.WorldBuilder = WorldBuilder;
// todo: read the Constructor parameters in order to throw early if a field is missing
function dataStructDeserializer(Constructor, data) {
    if (typeof data != 'object') {
        throw new Error(`Cannot default-deserialize ${Constructor.name}, because the data is of type ${typeof data}!`);
    }
    const obj = new Constructor();
    for (const kv of Object.entries(data)) {
        obj[kv[0]] = kv[1];
    }
    return obj;
}
function dataStructSerializer(component) {
    return component;
}
exports._ = {
    dataStructDeserializer,
    dataStructSerializer,
};
//# sourceMappingURL=world-builder.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/world.js":
/*!********************************************!*\
  !*** ./node_modules/sim-ecs/dist/world.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
exports.World = void 0;
const tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js");
const entity_1 = __webpack_require__(/*! ./entity */ "./node_modules/sim-ecs/dist/entity.js");
const entity_builder_1 = __webpack_require__(/*! ./entity-builder */ "./node_modules/sim-ecs/dist/entity-builder.js");
const state_1 = __webpack_require__(/*! ./state */ "./node_modules/sim-ecs/dist/state.js");
const pda_1 = __webpack_require__(/*! ./pda */ "./node_modules/sim-ecs/dist/pda.js");
const serde_1 = __webpack_require__(/*! ./serde/serde */ "./node_modules/sim-ecs/dist/serde/serde.js");
const commands_1 = __webpack_require__(/*! ./commands/commands */ "./node_modules/sim-ecs/dist/commands/commands.js");
const commands_aggregator_1 = __webpack_require__(/*! ./commands/commands-aggregator */ "./node_modules/sim-ecs/dist/commands/commands-aggregator.js");
const query_1 = __webpack_require__(/*! ./query */ "./node_modules/sim-ecs/dist/query.js");
tslib_1.__exportStar(__webpack_require__(/*! ./world.spec */ "./node_modules/sim-ecs/dist/world.spec.js"), exports);
class World {
    constructor(ecs, systemInfos = new Set(), _serde = new serde_1.SerDe()) {
        this.ecs = ecs;
        this.systemInfos = systemInfos;
        this._serde = _serde;
        this._dirty = false;
        this.entities = new Set();
        this.pda = new pda_1.PushDownAutomaton();
        this.groups = {
            nextHandle: 0,
            entityLinks: new Map(),
        };
        this.queries = [];
        this.resources = new Map();
        this.runExecutionPipeline = [];
        this.runExecutionPipelineCache = new Map();
        this.runPromise = undefined;
        this.shouldRunSystems = false;
        const self = this;
        this._commandsAggregator = new commands_aggregator_1.CommandsAggregator(this);
        this._commands = new commands_1.Commands(this, this._commandsAggregator);
        this.systemWorld = Object.freeze({
            get commands() {
                return self._commands;
            },
            get currentState() {
                return self.pda.state;
            },
            getEntities: this.getEntities.bind(this),
            getResource: this.getResource.bind(this),
        });
        this.transitionWorld = Object.freeze({
            get commands() {
                return self._commands;
            },
            get currentState() {
                return self.pda.state;
            },
            get serde() {
                return self.serde;
            },
            buildEntity: this.buildEntity.bind(this),
            flushCommands: this.flushCommands.bind(this),
            getEntities: this.getEntities.bind(this),
            getResource: this.getResource.bind(this),
            getResources: this.getResources.bind(this),
            maintain: this.maintain.bind(this),
            save: this.save.bind(this),
        });
        this.sortedSystems = this.sortSystems(this.systemInfos);
        for (const systemInfo of this.systemInfos) {
            if (systemInfo.system.query) {
                this.queries.push(systemInfo.system.query);
            }
        }
    }
    get commands() {
        return this._commands;
    }
    get dirty() {
        return this._dirty;
    }
    get running() {
        return this.shouldRunSystems;
    }
    get serde() {
        return this._serde;
    }
    addEntity(entity) {
        if (!this.entities.has(entity)) {
            this.entities.add(entity);
            this._dirty = true;
        }
    }
    addResource(obj, ...args) {
        let type;
        let instance;
        if (typeof obj === 'object') {
            type = obj.constructor;
            instance = obj;
        }
        else {
            type = obj;
            instance = new (obj.prototype.constructor.bind(obj, ...Array.from(arguments).slice(1)))();
        }
        if (this.resources.has(type)) {
            throw new Error(`Resource with name "${type.name}" already exists!`);
        }
        this.resources.set(type, instance);
        return instance;
    }
    buildEntity() {
        return new entity_builder_1.EntityBuilder();
    }
    clearEntities() {
        this.entities.clear();
    }
    createEntity() {
        const entity = new entity_1.Entity();
        this.entities.add(entity);
        this._dirty = true;
        return entity;
    }
    async dispatch(state) {
        await this.run({
            initialState: state,
            afterStepHandler: actions => actions.commands.stopRun(),
        });
    }
    flushCommands() {
        return this._commandsAggregator.executeAll();
    }
    getEntities(query) {
        if (!query) {
            return this.entities.keys();
        }
        const resultEntities = new Set();
        let entity;
        for (entity of this.entities.keys()) {
            if (query.matchesEntity(entity)) {
                resultEntities.add(entity);
            }
        }
        return resultEntities.values();
    }
    getResource(type) {
        if (!this.resources.has(type)) {
            throw new Error(`Resource of type "${type.name}" does not exist!`);
        }
        return this.resources.get(type);
    }
    getResources() {
        return this.resources.values();
    }
    load(prefab, options, intoGroup) {
        const entities = [];
        const groupHandle = intoGroup !== null && intoGroup !== void 0 ? intoGroup : this.groups.nextHandle++;
        let entity;
        for (entity of this._serde.deserialize(prefab, options).entities) {
            this.addEntity(entity);
            entities.push(entity);
        }
        this.groups.entityLinks.set(groupHandle, entities);
        return groupHandle;
    }
    // todo: add parameter which only maintains for a specific state
    // todo: maybe use a change-log to only maintain real changes instead of everything
    maintain() {
        let query;
        for (query of this.queries) {
            query[query_1.setEntitiesSym](this.entities.values());
        }
        this._dirty = false;
    }
    merge(elsewhere, intoGroup) {
        const groupHandle = intoGroup !== null && intoGroup !== void 0 ? intoGroup : this.groups.nextHandle++;
        const entities = [];
        let entity;
        for (entity of elsewhere.getEntities()) {
            this.addEntity(entity);
            entities.push(entity);
        }
        return [groupHandle, entities];
    }
    async popState() {
        var _a, _b;
        await ((_a = this.pda.pop()) === null || _a === void 0 ? void 0 : _a.deactivate(this.transitionWorld));
        const newState = this.pda.state;
        if (!newState) {
            this.runExecutionPipeline = [];
            return;
        }
        await newState.activate(this.transitionWorld);
        this.runExecutionPipeline = (_b = this.runExecutionPipelineCache.get(newState.constructor)) !== null && _b !== void 0 ? _b : [];
    }
    // todo: improve logic which sets up the groups (tracked by #13)
    prepareExecutionPipeline(state) {
        // todo: this could be further optimized by allowing systems with dependencies to run in parallel
        //    if all of their dependencies already ran
        // todo: also, if two systems depend on the same components, they may run in parallel
        //    if they only require READ access
        const result = [];
        const stateSystems = state.systems;
        let executionGroup = new Set();
        let shouldRunSystem;
        let systemInfo;
        if (this.sortedSystems.size == 0) {
            this.sortSystems(this.systemInfos);
        }
        for (systemInfo of this.sortedSystems) {
            shouldRunSystem = !!stateSystems.find(stateSys => stateSys.prototype.constructor.name === systemInfo.system.constructor.name);
            if (shouldRunSystem) {
                if (systemInfo.dependencies.size > 0) {
                    result.push(executionGroup);
                    executionGroup = new Set();
                }
                executionGroup.add(systemInfo.system);
            }
        }
        result.push(executionGroup);
        return result;
    }
    async pushState(NewState) {
        var _a, _b;
        await ((_a = this.pda.state) === null || _a === void 0 ? void 0 : _a.deactivate(this.transitionWorld));
        this.pda.push(NewState);
        const newState = this.pda.state;
        const registeredSystemNames = Array.from(this.systemInfos).map(nfo => nfo.system.constructor.name);
        for (const system of newState.systems) {
            if (!registeredSystemNames.includes(system.name)) {
                // cannot infer dependencies, so we have to throw :/
                throw new Error(`Did you forget to register System ${system.name}?`);
            }
        }
        if (this.runExecutionPipelineCache.has(NewState)) {
            this.runExecutionPipeline = (_b = this.runExecutionPipelineCache.get(NewState)) !== null && _b !== void 0 ? _b : [];
        }
        else {
            newState.create(this.transitionWorld);
            this.runExecutionPipeline = this.prepareExecutionPipeline(newState);
            this.runExecutionPipelineCache.set(NewState, this.runExecutionPipeline);
        }
        await newState.activate(this.transitionWorld);
    }
    async prepareRun(configuration) {
        var _a, _b, _c;
        if (this.runPromise) {
            throw new Error('The dispatch loop is already running!');
        }
        if (this._dirty) {
            this.maintain();
        }
        configuration || (configuration = {});
        const initialState = configuration.initialState
            ? configuration.initialState
            : state_1.State.bind(undefined, Array.from(this.systemInfos.values()).map(systemInfo => systemInfo.system.constructor));
        const runConfig = {
            afterStepHandler: (_a = configuration.afterStepHandler) !== null && _a !== void 0 ? _a : (_action => { }),
            beforeStepHandler: (_b = configuration.beforeStepHandler) !== null && _b !== void 0 ? _b : (_action => { }),
            executionFunction: (_c = configuration.executionFunction) !== null && _c !== void 0 ? _c : (typeof requestAnimationFrame == 'function'
                ? requestAnimationFrame
                : setTimeout),
            initialState,
        };
        this.pda.clear();
        this.shouldRunSystems = true;
        for (const systemInfo of this.systemInfos) {
            await systemInfo.system.setup(this.systemWorld);
        }
        await this.pushState(initialState);
        this.runExecutionPipeline = this.prepareExecutionPipeline(this.pda.state);
        this.lastRunPreparation = runConfig;
        return runConfig;
    }
    removeEntity(entity) {
        this.entities.delete(entity);
        this._dirty = true;
    }
    removeEntityFromSystems(entity) {
        this.removeEntity(entity);
        this.maintain();
    }
    replaceEntitiesWith(world) {
        this.clearEntities();
        this.merge(world);
    }
    replaceResource(obj, ...args) {
        let type;
        if (typeof obj === 'object') {
            type = obj.constructor;
        }
        else {
            type = obj;
        }
        if (!this.resources.has(type)) {
            throw new Error(`Resource with name "${type.name}" does not exists!`);
        }
        this.resources.delete(type);
        this.addResource(obj, ...args);
    }
    removeResource(type) {
        if (!this.resources.has(type)) {
            throw new Error(`Resource with name "${type.name}" does not exists!`);
        }
        this.resources.delete(type);
    }
    run(configuration, skipPreparation = false) {
        const runPromise = new Promise(async (resolver) => {
            let preparedConfig;
            await this._commandsAggregator.executeAll();
            if (!skipPreparation) {
                preparedConfig = await this.prepareRun(configuration);
            }
            else {
                preparedConfig = this.lastRunPreparation;
            }
            if (!preparedConfig) {
                throw new Error('Cannot run without preparing the run!');
            }
            this.runPromise = runPromise;
            const afterStepHandler = preparedConfig.afterStepHandler;
            const beforeStepHandler = preparedConfig.beforeStepHandler;
            const execFn = preparedConfig.executionFunction;
            let systemPromises;
            const cleanUp = async () => {
                var _a;
                await ((_a = this.pda.state) === null || _a === void 0 ? void 0 : _a.deactivate(this.transitionWorld));
                for (let state = this.pda.pop(); !!state; state = this.pda.pop()) {
                    await state.destroy(this.transitionWorld);
                }
                for (const systemInfo of this.systemInfos) {
                    await systemInfo.system.destroy(this.systemWorld);
                }
                this.runExecutionPipelineCache.clear();
                this.runPromise = undefined;
                resolver();
            };
            const mainLoop = async () => {
                if (!this.shouldRunSystems) {
                    await cleanUp();
                    return;
                }
                await beforeStepHandler(this.transitionWorld);
                {
                    let executionGroup;
                    let system;
                    for (executionGroup of this.runExecutionPipeline) {
                        systemPromises = [];
                        for (system of executionGroup) {
                            systemPromises.push(system.run(this.systemWorld));
                        }
                        await Promise.all(systemPromises);
                    }
                }
                await afterStepHandler(this.transitionWorld);
                await this._commandsAggregator.executeAll();
                execFn(mainLoop);
            };
            execFn(mainLoop);
        });
        return runPromise;
    }
    sortSystems(unsorted) {
        const unsortedArr = Array.from(unsorted);
        const graph = new Map(unsortedArr.map(node => [node.system.constructor, Array.from(node.dependencies)]));
        let edges;
        /// toposort with Kahn
        /// https://en.wikipedia.org/wiki/Topological_sorting#Kahn's_algorithm
        const L = []; // Empty list that will contain the sorted elements
        const S = Array.from(graph.entries()).filter(pair => pair[1].length === 0).map(pair => pair[0]); // Set of all nodes with no incoming edge
        let n;
        // while S is non-empty do
        while (S.length > 0) {
            // remove a node n from S
            n = S.shift();
            // add n to tail of L
            L.push(n);
            // for each node m with an edge e from n to m do
            for (let m of Array.from(graph.entries()).filter(pair => pair[1].includes(n)).map(pair => pair[0])) {
                // remove edge e from the graph
                edges = graph.get(m);
                edges.splice(edges.indexOf(n), 1);
                // if m has no other incoming edges then
                if (edges.length <= 0) {
                    // insert m into S
                    S.push(m);
                }
            }
        }
        if (Array.from(graph.values()).find(n => n.length > 0)) {
            throw new Error('The system dependency graph is cyclic!');
        }
        let obj;
        return new Set(L.map(t => {
            obj = unsortedArr.find(n => n.system.constructor == t);
            if (!obj) {
                throw new Error(`The system ${t.name} was not registered!`);
            }
            return obj;
        }));
    }
    stopRun() {
        this.shouldRunSystems = false;
    }
    save(query, options) {
        return this.serde.serialize({ entities: this.getEntities(query) }, options);
    }
    unloadPrefab(handle) {
        if (!this.groups.entityLinks.has(handle)) {
            throw new Error(`Could not find any loaded prefab under handle "${handle}"!`);
        }
        let entity;
        for (entity of this.groups.entityLinks.get(handle)) {
            this.removeEntity(entity);
        }
        this.groups.entityLinks.delete(handle);
    }
}
exports.World = World;
//# sourceMappingURL=world.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/dist/world.spec.js":
/*!*************************************************!*\
  !*** ./node_modules/sim-ecs/dist/world.spec.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {


Object.defineProperty(exports, "__esModule", ({ value: true }));
//# sourceMappingURL=world.spec.js.map

/***/ }),

/***/ "./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js":
/*!**************************************************************!*\
  !*** ./node_modules/sim-ecs/node_modules/tslib/tslib.es6.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "__extends": () => (/* binding */ __extends),
/* harmony export */   "__assign": () => (/* binding */ __assign),
/* harmony export */   "__rest": () => (/* binding */ __rest),
/* harmony export */   "__decorate": () => (/* binding */ __decorate),
/* harmony export */   "__param": () => (/* binding */ __param),
/* harmony export */   "__metadata": () => (/* binding */ __metadata),
/* harmony export */   "__awaiter": () => (/* binding */ __awaiter),
/* harmony export */   "__generator": () => (/* binding */ __generator),
/* harmony export */   "__createBinding": () => (/* binding */ __createBinding),
/* harmony export */   "__exportStar": () => (/* binding */ __exportStar),
/* harmony export */   "__values": () => (/* binding */ __values),
/* harmony export */   "__read": () => (/* binding */ __read),
/* harmony export */   "__spread": () => (/* binding */ __spread),
/* harmony export */   "__spreadArrays": () => (/* binding */ __spreadArrays),
/* harmony export */   "__spreadArray": () => (/* binding */ __spreadArray),
/* harmony export */   "__await": () => (/* binding */ __await),
/* harmony export */   "__asyncGenerator": () => (/* binding */ __asyncGenerator),
/* harmony export */   "__asyncDelegator": () => (/* binding */ __asyncDelegator),
/* harmony export */   "__asyncValues": () => (/* binding */ __asyncValues),
/* harmony export */   "__makeTemplateObject": () => (/* binding */ __makeTemplateObject),
/* harmony export */   "__importStar": () => (/* binding */ __importStar),
/* harmony export */   "__importDefault": () => (/* binding */ __importDefault),
/* harmony export */   "__classPrivateFieldGet": () => (/* binding */ __classPrivateFieldGet),
/* harmony export */   "__classPrivateFieldSet": () => (/* binding */ __classPrivateFieldSet)
/* harmony export */ });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    if (typeof b !== "function" && b !== null)
        throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = function() {
    __assign = Object.assign || function __assign(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    }
    return __assign.apply(this, arguments);
}

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

var __createBinding = Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
});

function __exportStar(m, o) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}

function __values(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

/** @deprecated */
function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** @deprecated */
function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
}

function __spreadArray(to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || from);
}

function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
}

function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
}

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
}

function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
    return cooked;
};

var __setModuleDefault = Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
};

function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
}

function __importDefault(mod) {
    return (mod && mod.__esModule) ? mod : { default: mod };
}

function __classPrivateFieldGet(receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}

function __classPrivateFieldSet(receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc2ltLWVjc19kaXN0X2luZGV4X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDRCQUE0QjtBQUM1QixnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBTztBQUMvQixpQkFBaUIsbUJBQU8sQ0FBQyx3REFBVztBQUNwQyxxQkFBcUIsbUJBQU8sQ0FBQywwR0FBK0I7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsa0Q7Ozs7Ozs7Ozs7QUNoQ2E7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUQ7Ozs7Ozs7Ozs7QUNGYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwwQkFBMEI7QUFDMUIsZ0JBQWdCLG1CQUFPLENBQUMscUVBQU87QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsb0dBQTRCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFdBQVc7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsK0M7Ozs7Ozs7Ozs7QUMzQmE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsb0Q7Ozs7Ozs7Ozs7QUNGYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0I7QUFDaEIsZ0JBQWdCLG1CQUFPLENBQUMscUVBQU87QUFDL0IsaUNBQWlDLG1CQUFPLENBQUMsZ0dBQTBCO0FBQ25FLHFCQUFxQixtQkFBTyxDQUFDLDhFQUFpQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFVBQVU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCxVQUFVO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsWUFBWTtBQUNqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0hBQW9IO0FBQ3BILHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsVUFBVTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHlHQUF5RztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFFBQVE7QUFDdEQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NB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UDtBQUNBLGlCQUFpQiw2Q0FBNkMsVUFBVSxzREFBc0QsY0FBYztBQUM1SSwwQkFBMEIsNkJBQTZCLG9CQUFvQixnREFBZ0Qsa0JBQWtCO0FBQzdJO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwyR0FBMkcsdUZBQXVGLGNBQWM7QUFDaE4sdUJBQXVCLDhCQUE4QixnREFBZ0Qsd0RBQXdEO0FBQzdKLDZDQUE2QyxzQ0FBc0MsVUFBVSxtQkFBbUIsSUFBSTtBQUNwSDtBQUNBO0FBQ087QUFDUCxpQ0FBaUMsdUNBQXVDLFlBQVksS0FBSyxPQUFPO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1AsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9jb21tYW5kcy9jb21tYW5kLWVudGl0eS1idWlsZGVyLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9kaXN0L2NvbW1hbmRzL2NvbW1hbmQtZW50aXR5LWJ1aWxkZXIuc3BlYy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9jb21tYW5kcy9jb21tYW5kcy1hZ2dyZWdhdG9yLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9kaXN0L2NvbW1hbmRzL2NvbW1hbmRzLWFnZ3JlZ2F0b3Iuc3BlYy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9jb21tYW5kcy9jb21tYW5kcy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9jb21tYW5kcy9jb21tYW5kcy5zcGVjLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9kaXN0L2Vjcy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9lbnRpdHktYnVpbGRlci5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9lbnRpdHktYnVpbGRlci5zcGVjLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9kaXN0L2VudGl0eS5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9lbnRpdHkuc3BlYy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9wZGEuanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3QvcXVlcnkuanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3QvcXVlcnkuc3BlYy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9zZXJkZS9kZWZhdWx0LWhhbmRsZXJzLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9kaXN0L3NlcmRlL3NlcmRlLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9kaXN0L3NlcmRlL3NlcmRlLnNwZWMuanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3Qvc2VyZGUvc2VyaWFsLWZvcm1hdC5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9zZXJkZS9zZXJpYWwtZm9ybWF0LnNwZWMuanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3Qvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3Qvc3RhdGUuc3BlYy5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC9zeXN0ZW0uanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3Qvc3lzdGVtLnNwZWMuanMiLCJ3ZWJwYWNrOi8vY2l0eWxpZ2h0cy8uL25vZGVfbW9kdWxlcy9zaW0tZWNzL2Rpc3Qvd29ybGQtYnVpbGRlci5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC93b3JsZC5qcyIsIndlYnBhY2s6Ly9jaXR5bGlnaHRzLy4vbm9kZV9tb2R1bGVzL3NpbS1lY3MvZGlzdC93b3JsZC5zcGVjLmpzIiwid2VicGFjazovL2NpdHlsaWdodHMvLi9ub2RlX21vZHVsZXMvc2ltLWVjcy9ub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29tbWFuZEVudGl0eUJ1aWxkZXIgPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbmNvbnN0IGVudGl0eV8xID0gcmVxdWlyZShcIi4uL2VudGl0eVwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbWFuZC1lbnRpdHktYnVpbGRlci5zcGVjXCIpLCBleHBvcnRzKTtcclxuY2xhc3MgQ29tbWFuZEVudGl0eUJ1aWxkZXIge1xyXG4gICAgY29uc3RydWN0b3IoY29tbWFuZHMpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzID0gY29tbWFuZHM7XHJcbiAgICAgICAgdGhpcy5lbnRpdHkgPSBuZXcgZW50aXR5XzEuRW50aXR5KCk7XHJcbiAgICB9XHJcbiAgICBidWlsZCgpIHtcclxuICAgICAgICB0aGlzLmNvbW1hbmRzLmFnZ3JlZ2F0b3IuYWRkQ29tbWFuZCgoKSA9PiB0aGlzLmNvbW1hbmRzLndvcmxkLmFkZEVudGl0eSh0aGlzLmVudGl0eSkpO1xyXG4gICAgfVxyXG4gICAgd2l0aChjb21wb25lbnQsIC4uLmFyZ3MpIHtcclxuICAgICAgICB0aGlzLmVudGl0eS5hZGRDb21wb25lbnQodGhpcy5hc0NvbXBvbmVudChjb21wb25lbnQpKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhBbGwoLi4uY29tcG9uZW50cykge1xyXG4gICAgICAgIGxldCBjb21wb25lbnQ7XHJcbiAgICAgICAgZm9yIChjb21wb25lbnQgb2YgY29tcG9uZW50cykge1xyXG4gICAgICAgICAgICB0aGlzLndpdGgoY29tcG9uZW50KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhc0NvbXBvbmVudChjb21wb25lbnQsIC4uLmFyZ3MpIHtcclxuICAgICAgICByZXR1cm4gdHlwZW9mIGNvbXBvbmVudCA9PT0gJ29iamVjdCdcclxuICAgICAgICAgICAgPyBjb21wb25lbnRcclxuICAgICAgICAgICAgOiBuZXcgKGNvbXBvbmVudC5wcm90b3R5cGUuY29uc3RydWN0b3IuYmluZChjb21wb25lbnQsIC4uLkFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgxKSkpKCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db21tYW5kRW50aXR5QnVpbGRlciA9IENvbW1hbmRFbnRpdHlCdWlsZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb21tYW5kLWVudGl0eS1idWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1hbmQtZW50aXR5LWJ1aWxkZXIuc3BlYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkNvbW1hbmRzQWdncmVnYXRvciA9IHZvaWQgMDtcclxuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tbWFuZHMtYWdncmVnYXRvci5zcGVjXCIpLCBleHBvcnRzKTtcclxuY2xhc3MgQ29tbWFuZHNBZ2dyZWdhdG9yIHtcclxuICAgIGNvbnN0cnVjdG9yKHdvcmxkKSB7XHJcbiAgICAgICAgdGhpcy53b3JsZCA9IHdvcmxkO1xyXG4gICAgICAgIHRoaXMuY29tbWFuZHMgPSBbXTtcclxuICAgICAgICB0aGlzLmRvTWFpbnRhaW4gPSBmYWxzZTtcclxuICAgIH1cclxuICAgIGFkZENvbW1hbmQoY29tbWFuZCkge1xyXG4gICAgICAgIHRoaXMuY29tbWFuZHMucHVzaChjb21tYW5kKTtcclxuICAgIH1cclxuICAgIGFzeW5jIGV4ZWN1dGVBbGwoKSB7XHJcbiAgICAgICAgZm9yIChsZXQgY29tbWFuZCA9IHRoaXMuY29tbWFuZHMuc2hpZnQoKTsgISFjb21tYW5kOyBjb21tYW5kID0gdGhpcy5jb21tYW5kcy5zaGlmdCgpKSB7XHJcbiAgICAgICAgICAgIGF3YWl0IGNvbW1hbmQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuZG9NYWludGFpbikge1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkLm1haW50YWluKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdHJpZ2dlck1haW50YWluKCkge1xyXG4gICAgICAgIHRoaXMuZG9NYWludGFpbiA9IHRydWU7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5Db21tYW5kc0FnZ3JlZ2F0b3IgPSBDb21tYW5kc0FnZ3JlZ2F0b3I7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1hbmRzLWFnZ3JlZ2F0b3IuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y29tbWFuZHMtYWdncmVnYXRvci5zcGVjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuQ29tbWFuZHMgPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbmNvbnN0IGNvbW1hbmRfZW50aXR5X2J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL2NvbW1hbmQtZW50aXR5LWJ1aWxkZXJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbW1hbmRzLnNwZWNcIiksIGV4cG9ydHMpO1xyXG5jbGFzcyBDb21tYW5kcyB7XHJcbiAgICBjb25zdHJ1Y3Rvcih3b3JsZCwgYWdncmVnYXRvcikge1xyXG4gICAgICAgIHRoaXMud29ybGQgPSB3b3JsZDtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IgPSBhZ2dyZWdhdG9yO1xyXG4gICAgfVxyXG4gICAgYWRkRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRDb21tYW5kKCgpID0+IHRoaXMud29ybGQuYWRkRW50aXR5KGVudGl0eSkpO1xyXG4gICAgfVxyXG4gICAgYWRkUmVzb3VyY2Uob2JqLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgbGV0IHR5cGU7XHJcbiAgICAgICAgbGV0IGluc3RhbmNlO1xyXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgICAgICB0eXBlID0gb2JqLmNvbnN0cnVjdG9yO1xyXG4gICAgICAgICAgICBpbnN0YW5jZSA9IG9iajtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBvYmo7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gbmV3IChvYmoucHJvdG90eXBlLmNvbnN0cnVjdG9yLmJpbmQob2JqLCAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkpKSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy53b3JsZC5yZXNvdXJjZXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugd2l0aCBuYW1lIFwiJHt0eXBlLm5hbWV9XCIgYWxyZWFkeSBleGlzdHMhYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRDb21tYW5kKCgpID0+IHtcclxuICAgICAgICAgICAgaWYgKHRoaXMud29ybGQucmVzb3VyY2VzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSB3aXRoIG5hbWUgXCIke3R5cGUubmFtZX1cIiBhbHJlYWR5IGV4aXN0cyFgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndvcmxkLnJlc291cmNlcy5zZXQodHlwZSwgaW5zdGFuY2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuICAgIGJ1aWxkRW50aXR5KCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgY29tbWFuZF9lbnRpdHlfYnVpbGRlcl8xLkNvbW1hbmRFbnRpdHlCdWlsZGVyKHRoaXMpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJFbnRpdGllcygpIHtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IuYWRkQ29tbWFuZCgoKSA9PiB0aGlzLndvcmxkLmVudGl0aWVzLmNsZWFyKCkpO1xyXG4gICAgfVxyXG4gICAgbG9hZChwcmVmYWIsIG9wdGlvbnMpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLndvcmxkLmdyb3Vwcy5uZXh0SGFuZGxlKys7XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yLmFkZENvbW1hbmQoKCkgPT4geyB0aGlzLndvcmxkLmxvYWQocHJlZmFiLCBvcHRpb25zLCBoYW5kbGUpOyB9KTtcclxuICAgICAgICByZXR1cm4gaGFuZGxlO1xyXG4gICAgfVxyXG4gICAgbWFpbnRhaW4oKSB7XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yLnRyaWdnZXJNYWludGFpbigpO1xyXG4gICAgfVxyXG4gICAgbWVyZ2Uod29ybGQpIHtcclxuICAgICAgICBjb25zdCBoYW5kbGUgPSB0aGlzLndvcmxkLmdyb3Vwcy5uZXh0SGFuZGxlKys7XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yLmFkZENvbW1hbmQoKCkgPT4geyB0aGlzLndvcmxkLm1lcmdlKHdvcmxkLCBoYW5kbGUpOyB9KTtcclxuICAgICAgICByZXR1cm4gaGFuZGxlO1xyXG4gICAgfVxyXG4gICAgcG9wU3RhdGUoKSB7XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yLmFkZENvbW1hbmQoKCkgPT4gdGhpcy53b3JsZC5wb3BTdGF0ZSgpKTtcclxuICAgIH1cclxuICAgIHB1c2hTdGF0ZShOZXdTdGF0ZSkge1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRDb21tYW5kKCgpID0+IHRoaXMud29ybGQucHVzaFN0YXRlKE5ld1N0YXRlKSk7XHJcbiAgICB9XHJcbiAgICBxdWV1ZUNvbW1hbmQoY29tbWFuZCkge1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRDb21tYW5kKGNvbW1hbmQpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlRW50aXR5KGVudGl0eSkge1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRDb21tYW5kKCgpID0+IHRoaXMud29ybGQucmVtb3ZlRW50aXR5KGVudGl0eSkpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVzb3VyY2UodHlwZSkge1xyXG4gICAgICAgIGlmICghdGhpcy53b3JsZC5yZXNvdXJjZXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugd2l0aCBuYW1lIFwiJHt0eXBlLm5hbWV9XCIgZG9lcyBub3QgZXhpc3RzIWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IuYWRkQ29tbWFuZCgoKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy53b3JsZC5yZXNvdXJjZXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIHdpdGggbmFtZSBcIiR7dHlwZS5uYW1lfVwiIGRvZXMgbm90IGV4aXN0cyFgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLndvcmxkLnJlc291cmNlcy5kZWxldGUodHlwZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICByZXBsYWNlUmVzb3VyY2Uob2JqLCAuLi5hcmdzKSB7XHJcbiAgICAgICAgbGV0IHR5cGU7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBvYmouY29uc3RydWN0b3I7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0eXBlID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMud29ybGQucmVzb3VyY2VzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIHdpdGggbmFtZSBcIiR7dHlwZS5uYW1lfVwiIGRvZXMgbm90IGV4aXN0cyFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5hZ2dyZWdhdG9yLmFkZENvbW1hbmQoKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMud29ybGQucmVzb3VyY2VzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSB3aXRoIG5hbWUgXCIke3R5cGUubmFtZX1cIiBkb2VzIG5vdCBleGlzdHMhYCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy53b3JsZC5yZXNvdXJjZXMuZGVsZXRlKHR5cGUpO1xyXG4gICAgICAgICAgICB0aGlzLndvcmxkLmFkZFJlc291cmNlKG9iaiwgLi4uYXJncyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzdG9wUnVuKCkge1xyXG4gICAgICAgIHRoaXMuYWdncmVnYXRvci5hZGRDb21tYW5kKCgpID0+IHRoaXMud29ybGQuc3RvcFJ1bigpKTtcclxuICAgIH1cclxuICAgIHVubG9hZFByZWZhYihoYW5kbGUpIHtcclxuICAgICAgICB0aGlzLmFnZ3JlZ2F0b3IuYWRkQ29tbWFuZCgoKSA9PiB0aGlzLndvcmxkLnVubG9hZFByZWZhYihoYW5kbGUpKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLkNvbW1hbmRzID0gQ29tbWFuZHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1hbmRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNvbW1hbmRzLnNwZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5FQ1MgPSB2b2lkIDA7XHJcbmNvbnN0IHdvcmxkX2J1aWxkZXJfMSA9IHJlcXVpcmUoXCIuL3dvcmxkLWJ1aWxkZXJcIik7XHJcbmNsYXNzIEVDUyB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLndvcmxkcyA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGJ1aWxkV29ybGQobmFtZSkge1xyXG4gICAgICAgIHJldHVybiBuZXcgd29ybGRfYnVpbGRlcl8xLldvcmxkQnVpbGRlcih0aGlzKS5hZGRDYWxsYmFjayh3b3JsZCA9PiB0aGlzLndvcmxkcy5zZXQod29ybGQsIHsgbmFtZSwgd29ybGQgfSkpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlV29ybGQod29ybGQpIHtcclxuICAgICAgICB0aGlzLndvcmxkcy5kZWxldGUod29ybGQpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRUNTID0gRUNTO1xyXG5leHBvcnRzLmRlZmF1bHQgPSBFQ1M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVjcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkVudGl0eUJ1aWxkZXIgPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbmNvbnN0IGVudGl0eV8xID0gcmVxdWlyZShcIi4vZW50aXR5XCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbnRpdHktYnVpbGRlci5zcGVjXCIpLCBleHBvcnRzKTtcclxuY2xhc3MgRW50aXR5QnVpbGRlciB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLmVudGl0eSA9IG5ldyBlbnRpdHlfMS5FbnRpdHkoKTtcclxuICAgIH1cclxuICAgIGJ1aWxkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmVudGl0eTtcclxuICAgIH1cclxuICAgIHdpdGgoY29tcG9uZW50LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgdGhpcy5lbnRpdHkuYWRkQ29tcG9uZW50KHRoaXMuYXNDb21wb25lbnQoY29tcG9uZW50KSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoQWxsKC4uLmNvbXBvbmVudHMpIHtcclxuICAgICAgICBsZXQgY29tcG9uZW50O1xyXG4gICAgICAgIGZvciAoY29tcG9uZW50IG9mIGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgdGhpcy53aXRoKGNvbXBvbmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgYXNDb21wb25lbnQoY29tcG9uZW50LCAuLi5hcmdzKSB7XHJcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjb21wb25lbnQgPT09ICdvYmplY3QnXHJcbiAgICAgICAgICAgID8gY29tcG9uZW50XHJcbiAgICAgICAgICAgIDogbmV3IChjb21wb25lbnQucHJvdG90eXBlLmNvbnN0cnVjdG9yLmJpbmQoY29tcG9uZW50LCAuLi5BcnJheS5mcm9tKGFyZ3VtZW50cykuc2xpY2UoMSkpKSgpO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuRW50aXR5QnVpbGRlciA9IEVudGl0eUJ1aWxkZXI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudGl0eS1idWlsZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudGl0eS1idWlsZGVyLnNwZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5FbnRpdHkgPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2VudGl0eS5zcGVjXCIpLCBleHBvcnRzKTtcclxuY2xhc3MgRW50aXR5IHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnRhZ3MgPSBuZXcgU2V0KCk7XHJcbiAgICB9XHJcbiAgICBhZGRDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgaWYgKHRoaXMuaGFzQ29tcG9uZW50KGNvbXBvbmVudC5jb25zdHJ1Y3RvcikpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb21wb25lbnQgXCIke2NvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lfVwiIGFscmVhZHkgZXhpc3RzIG9uIGVudGl0eSFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzLnNldChjb21wb25lbnQuY29uc3RydWN0b3IsIGNvbXBvbmVudCk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBhZGRUYWcodGFnKSB7XHJcbiAgICAgICAgdGhpcy50YWdzLmFkZCh0YWcpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZ2V0Q29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMuZ2V0KGNvbXBvbmVudCk7XHJcbiAgICB9XHJcbiAgICBnZXRDb21wb25lbnRzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLmNvbXBvbmVudHMudmFsdWVzKCk7XHJcbiAgICB9XHJcbiAgICBnZXRUYWdzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnRhZ3MudmFsdWVzKCk7XHJcbiAgICB9XHJcbiAgICBoYXNDb21wb25lbnQoY29tcG9uZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcG9uZW50cy5oYXMoY29tcG9uZW50KTtcclxuICAgIH1cclxuICAgIGhhc1RhZyh0YWcpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy50YWdzLmhhcyh0YWcpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlQ29tcG9uZW50KGNvbXBvbmVudCkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50cy5kZWxldGUoY29tcG9uZW50LmNvbnN0cnVjdG9yKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHJlbW92ZVRhZyh0YWcpIHtcclxuICAgICAgICB0aGlzLnRhZ3MuZGVsZXRlKHRhZyk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5FbnRpdHkgPSBFbnRpdHk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVudGl0eS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1lbnRpdHkuc3BlYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lY3NcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbnRpdHlcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9lbnRpdHktYnVpbGRlclwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3F1ZXJ5XCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VyZGUvc2VyZGVcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJkZS9zZXJpYWwtZm9ybWF0XCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RhdGVcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zeXN0ZW1cIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi93b3JsZFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuUHVzaERvd25BdXRvbWF0b24gPSB2b2lkIDA7XHJcbmNsYXNzIFB1c2hEb3duQXV0b21hdG9uIHtcclxuICAgIGdldCBzdGF0ZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5jdXJyZW50U3RhdGU7XHJcbiAgICB9XHJcbiAgICBjbGVhcigpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnN0YXRlc1RhaWwgPSB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBwb3AoKSB7XHJcbiAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZXNUYWlsKVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgY29uc3Qgb2xkVGFpbCA9IHRoaXMuc3RhdGVzVGFpbDtcclxuICAgICAgICB0aGlzLnN0YXRlc1RhaWwgPSB0aGlzLnN0YXRlc1RhaWwucHJldk5vZGU7XHJcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhdGUgPSAoX2EgPSB0aGlzLnN0YXRlc1RhaWwpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0ZTtcclxuICAgICAgICByZXR1cm4gb2xkVGFpbC5zdGF0ZTtcclxuICAgIH1cclxuICAgIHB1c2goU3RhdGUpIHtcclxuICAgICAgICB0aGlzLmN1cnJlbnRTdGF0ZSA9IG5ldyBTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuc3RhdGVzVGFpbCA9IHtcclxuICAgICAgICAgICAgcHJldk5vZGU6IHRoaXMuc3RhdGVzVGFpbCxcclxuICAgICAgICAgICAgc3RhdGU6IHRoaXMuY3VycmVudFN0YXRlLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5QdXNoRG93bkF1dG9tYXRvbiA9IFB1c2hEb3duQXV0b21hdG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wZGEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5XaXRob3V0VGFnID0gZXhwb3J0cy5XaXRob3V0ID0gZXhwb3J0cy5XaXRoVGFnID0gZXhwb3J0cy5XaXRoID0gZXhwb3J0cy5Xcml0ZSA9IGV4cG9ydHMuUmVhZCA9IGV4cG9ydHMuUmVhZEVudGl0eSA9IGV4cG9ydHMuUXVlcnkgPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbmNvbnN0IHF1ZXJ5X3NwZWNfMSA9IHJlcXVpcmUoXCIuL3F1ZXJ5LnNwZWNcIik7XHJcbmNvbnN0IGVudGl0eV8xID0gcmVxdWlyZShcIi4vZW50aXR5XCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9xdWVyeS5zcGVjXCIpLCBleHBvcnRzKTtcclxuLy8gdG9kbzogUmVhZEVudGl0eSgpIHNob3VsZCBhbHNvIHdvcmtcclxuY2xhc3MgUXVlcnkge1xyXG4gICAgY29uc3RydWN0b3IocXVlcnlEZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeURlc2NyaXB0b3IgPSBxdWVyeURlc2NyaXB0b3I7XHJcbiAgICAgICAgdGhpcy5xdWVyeVJlc3VsdCA9IG5ldyBNYXAoKTtcclxuICAgIH1cclxuICAgIGdldCBkZXNjcmlwdG9yKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnF1ZXJ5RGVzY3JpcHRvcjtcclxuICAgIH1cclxuICAgIFtxdWVyeV9zcGVjXzEuYWRkRW50aXR5U3ltXShlbnRpdHkpIHtcclxuICAgICAgICBpZiAodGhpcy5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcclxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5xdWVyeURlc2NyaXB0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5UmVzdWx0LnNldChlbnRpdHksIGVudGl0eSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnF1ZXJ5UmVzdWx0LnNldChlbnRpdHksIHRoaXMuZ2V0RGF0YUZyb21FbnRpdHkoZW50aXR5LCB0aGlzLnF1ZXJ5RGVzY3JpcHRvcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgW3F1ZXJ5X3NwZWNfMS5jbGVhckVudGl0aWVzU3ltXSgpIHtcclxuICAgICAgICB0aGlzLnF1ZXJ5UmVzdWx0LmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBbcXVlcnlfc3BlY18xLnJlbW92ZUVudGl0eVN5bV0oZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5xdWVyeVJlc3VsdC5kZWxldGUoZW50aXR5KTtcclxuICAgIH1cclxuICAgIFtxdWVyeV9zcGVjXzEuc2V0RW50aXRpZXNTeW1dKGVudGl0aWVzKSB7XHJcbiAgICAgICAgbGV0IGVudGl0eTtcclxuICAgICAgICB0aGlzLnF1ZXJ5UmVzdWx0LmNsZWFyKCk7XHJcbiAgICAgICAgZm9yIChlbnRpdHkgb2YgZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdGhpc1txdWVyeV9zcGVjXzEuYWRkRW50aXR5U3ltXShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGV4ZWN1dGUoaGFuZGxlcikge1xyXG4gICAgICAgIGxldCBkYXRhO1xyXG4gICAgICAgIGZvciAoZGF0YSBvZiB0aGlzLnF1ZXJ5UmVzdWx0LnZhbHVlcygpKSB7XHJcbiAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZ2V0RGF0YUZyb21FbnRpdHkoZW50aXR5LCBkZXNjcmlwdG9yKSB7XHJcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHt9O1xyXG4gICAgICAgIGxldCBjb21wb25lbnREZXNjO1xyXG4gICAgICAgIGZvciAoY29tcG9uZW50RGVzYyBvZiBPYmplY3QuZW50cmllcyhkZXNjcmlwdG9yKSkge1xyXG4gICAgICAgICAgICBpZiAoY29tcG9uZW50RGVzY1sxXVtxdWVyeV9zcGVjXzEuYWNjZXNzRGVzY1N5bV0udHlwZSA9PSBxdWVyeV9zcGVjXzEuRUFjY2Vzcy5tZXRhKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50RGVzY1sxXVtxdWVyeV9zcGVjXzEuYWNjZXNzRGVzY1N5bV0udGFyZ2V0VHlwZSA9PSBxdWVyeV9zcGVjXzEuRVRhcmdldFR5cGUuZW50aXR5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50c1tjb21wb25lbnREZXNjWzBdXSA9IGVudGl0eTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50RGVzY1swXV0gPSBlbnRpdHkuZ2V0Q29tcG9uZW50KGNvbXBvbmVudERlc2NbMV1bcXVlcnlfc3BlY18xLmFjY2Vzc0Rlc2NTeW1dLnRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNvbXBvbmVudHM7XHJcbiAgICB9XHJcbiAgICBpdGVyKHdvcmxkKSB7XHJcbiAgICAgICAgaWYgKHdvcmxkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBbXTtcclxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBmaWd1cmUgb3V0IHdoeSB0aGUgdHlwZSBzeXN0ZW0gZXJyb3JzIGB0aGlzYFxyXG4gICAgICAgICAgICBjb25zdCBlbnRpdGllcyA9IHdvcmxkLmdldEVudGl0aWVzKHRoaXMpO1xyXG4gICAgICAgICAgICBsZXQgZW50aXR5O1xyXG4gICAgICAgICAgICBmb3IgKGVudGl0eSBvZiBlbnRpdGllcykge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5wdXNoKHRoaXMuZ2V0RGF0YUZyb21FbnRpdHkoZW50aXR5LCB0aGlzLnF1ZXJ5RGVzY3JpcHRvcikpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnZhbHVlcygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucXVlcnlSZXN1bHQudmFsdWVzKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgbWF0Y2hlc0VudGl0eShlbnRpdHkpIHtcclxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLnF1ZXJ5RGVzY3JpcHRvcikpIHtcclxuICAgICAgICAgICAgbGV0IGNvbXBvbmVudERlc2M7XHJcbiAgICAgICAgICAgIGZvciAoY29tcG9uZW50RGVzYyBvZiB0aGlzLnF1ZXJ5RGVzY3JpcHRvcikge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudERlc2NbcXVlcnlfc3BlY18xLmV4aXN0ZW5jZURlc2NTeW1dLnRhcmdldFR5cGUgPT0gcXVlcnlfc3BlY18xLkVUYXJnZXRUeXBlLnRhZ1xyXG4gICAgICAgICAgICAgICAgICAgICYmIGVudGl0eS5oYXNUYWcoY29tcG9uZW50RGVzY1txdWVyeV9zcGVjXzEuZXhpc3RlbmNlRGVzY1N5bV0udGFyZ2V0KSAhPSAoY29tcG9uZW50RGVzY1txdWVyeV9zcGVjXzEuZXhpc3RlbmNlRGVzY1N5bV0udHlwZSA9PSBxdWVyeV9zcGVjXzEuRUV4aXN0ZW5jZS5zZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudERlc2NbcXVlcnlfc3BlY18xLmV4aXN0ZW5jZURlc2NTeW1dLnRhcmdldFR5cGUgPT0gcXVlcnlfc3BlY18xLkVUYXJnZXRUeXBlLmNvbXBvbmVudFxyXG4gICAgICAgICAgICAgICAgICAgICYmIGVudGl0eS5oYXNDb21wb25lbnQoY29tcG9uZW50RGVzY1txdWVyeV9zcGVjXzEuZXhpc3RlbmNlRGVzY1N5bV0udGFyZ2V0KSAhPSAoY29tcG9uZW50RGVzY1txdWVyeV9zcGVjXzEuZXhpc3RlbmNlRGVzY1N5bV0udHlwZSA9PSBxdWVyeV9zcGVjXzEuRUV4aXN0ZW5jZS5zZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBsZXQgY29tcG9uZW50RGVzYztcclxuICAgICAgICAgICAgZm9yIChjb21wb25lbnREZXNjIG9mIE9iamVjdC52YWx1ZXModGhpcy5xdWVyeURlc2NyaXB0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY29tcG9uZW50RGVzY1txdWVyeV9zcGVjXzEuYWNjZXNzRGVzY1N5bV0udGFyZ2V0VHlwZSA9PSBxdWVyeV9zcGVjXzEuRVRhcmdldFR5cGUudGFnXHJcbiAgICAgICAgICAgICAgICAgICAgJiYgIWVudGl0eS5oYXNUYWcoY29tcG9uZW50RGVzY1txdWVyeV9zcGVjXzEuYWNjZXNzRGVzY1N5bV0udGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjb21wb25lbnREZXNjW3F1ZXJ5X3NwZWNfMS5hY2Nlc3NEZXNjU3ltXS50YXJnZXRUeXBlID09IHF1ZXJ5X3NwZWNfMS5FVGFyZ2V0VHlwZS5jb21wb25lbnRcclxuICAgICAgICAgICAgICAgICAgICAmJiAhZW50aXR5Lmhhc0NvbXBvbmVudChjb21wb25lbnREZXNjW3F1ZXJ5X3NwZWNfMS5hY2Nlc3NEZXNjU3ltXS50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuUXVlcnkgPSBRdWVyeTtcclxuZnVuY3Rpb24gUmVhZEVudGl0eSgpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBlbnRpdHlfMS5FbnRpdHksIHtcclxuICAgICAgICBbcXVlcnlfc3BlY18xLmFjY2Vzc0Rlc2NTeW1dOiB7XHJcbiAgICAgICAgICAgIHRhcmdldDogZW50aXR5XzEuRW50aXR5LFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiBxdWVyeV9zcGVjXzEuRVRhcmdldFR5cGUuZW50aXR5LFxyXG4gICAgICAgICAgICB0eXBlOiBxdWVyeV9zcGVjXzEuRUFjY2Vzcy5tZXRhLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLlJlYWRFbnRpdHkgPSBSZWFkRW50aXR5O1xyXG5mdW5jdGlvbiBSZWFkKGNvbXBvbmVudFByb3RvdHlwZSkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbXBvbmVudFByb3RvdHlwZS5wcm90b3R5cGUsIHtcclxuICAgICAgICBbcXVlcnlfc3BlY18xLmFjY2Vzc0Rlc2NTeW1dOiB7XHJcbiAgICAgICAgICAgIHRhcmdldDogY29tcG9uZW50UHJvdG90eXBlLFxyXG4gICAgICAgICAgICB0YXJnZXRUeXBlOiBxdWVyeV9zcGVjXzEuRVRhcmdldFR5cGUuY29tcG9uZW50LFxyXG4gICAgICAgICAgICB0eXBlOiBxdWVyeV9zcGVjXzEuRUFjY2Vzcy5yZWFkLFxyXG4gICAgICAgIH0sXHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLlJlYWQgPSBSZWFkO1xyXG5mdW5jdGlvbiBXcml0ZShjb21wb25lbnRQcm90b3R5cGUpIHtcclxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21wb25lbnRQcm90b3R5cGUucHJvdG90eXBlLCB7XHJcbiAgICAgICAgW3F1ZXJ5X3NwZWNfMS5hY2Nlc3NEZXNjU3ltXToge1xyXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbXBvbmVudFByb3RvdHlwZSxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogcXVlcnlfc3BlY18xLkVUYXJnZXRUeXBlLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgdHlwZTogcXVlcnlfc3BlY18xLkVBY2Nlc3Mud3JpdGUsXHJcbiAgICAgICAgfSxcclxuICAgIH0pO1xyXG59XHJcbmV4cG9ydHMuV3JpdGUgPSBXcml0ZTtcclxuZnVuY3Rpb24gV2l0aChjb21wb25lbnRQcm90b3R5cGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgW3F1ZXJ5X3NwZWNfMS5leGlzdGVuY2VEZXNjU3ltXToge1xyXG4gICAgICAgICAgICB0YXJnZXQ6IGNvbXBvbmVudFByb3RvdHlwZSxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogcXVlcnlfc3BlY18xLkVUYXJnZXRUeXBlLmNvbXBvbmVudCxcclxuICAgICAgICAgICAgdHlwZTogcXVlcnlfc3BlY18xLkVFeGlzdGVuY2Uuc2V0LFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5XaXRoID0gV2l0aDtcclxuZnVuY3Rpb24gV2l0aFRhZyh0YWcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgW3F1ZXJ5X3NwZWNfMS5hY2Nlc3NEZXNjU3ltXToge1xyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhZyxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogcXVlcnlfc3BlY18xLkVUYXJnZXRUeXBlLnRhZyxcclxuICAgICAgICAgICAgdHlwZTogcXVlcnlfc3BlY18xLkVBY2Nlc3MubWV0YSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIFtxdWVyeV9zcGVjXzEuZXhpc3RlbmNlRGVzY1N5bV06IHtcclxuICAgICAgICAgICAgdGFyZ2V0OiB0YWcsXHJcbiAgICAgICAgICAgIHRhcmdldFR5cGU6IHF1ZXJ5X3NwZWNfMS5FVGFyZ2V0VHlwZS50YWcsXHJcbiAgICAgICAgICAgIHR5cGU6IHF1ZXJ5X3NwZWNfMS5FRXhpc3RlbmNlLnNldCxcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuV2l0aFRhZyA9IFdpdGhUYWc7XHJcbmZ1bmN0aW9uIFdpdGhvdXQoY29tcG9uZW50UHJvdG90eXBlKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIFtxdWVyeV9zcGVjXzEuZXhpc3RlbmNlRGVzY1N5bV06IHtcclxuICAgICAgICAgICAgdGFyZ2V0OiBjb21wb25lbnRQcm90b3R5cGUsXHJcbiAgICAgICAgICAgIHRhcmdldFR5cGU6IHF1ZXJ5X3NwZWNfMS5FVGFyZ2V0VHlwZS5jb21wb25lbnQsXHJcbiAgICAgICAgICAgIHR5cGU6IHF1ZXJ5X3NwZWNfMS5FRXhpc3RlbmNlLnVuc2V0LFxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5XaXRob3V0ID0gV2l0aG91dDtcclxuZnVuY3Rpb24gV2l0aG91dFRhZyh0YWcpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgW3F1ZXJ5X3NwZWNfMS5leGlzdGVuY2VEZXNjU3ltXToge1xyXG4gICAgICAgICAgICB0YXJnZXQ6IHRhZyxcclxuICAgICAgICAgICAgdGFyZ2V0VHlwZTogcXVlcnlfc3BlY18xLkVUYXJnZXRUeXBlLnRhZyxcclxuICAgICAgICAgICAgdHlwZTogcXVlcnlfc3BlY18xLkVFeGlzdGVuY2UudW5zZXQsXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLldpdGhvdXRUYWcgPSBXaXRob3V0VGFnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1xdWVyeS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLkVUYXJnZXRUeXBlID0gZXhwb3J0cy5FRXhpc3RlbmNlID0gZXhwb3J0cy5FQWNjZXNzID0gZXhwb3J0cy5leGlzdGVuY2VEZXNjU3ltID0gZXhwb3J0cy5hY2Nlc3NEZXNjU3ltID0gZXhwb3J0cy5zZXRFbnRpdGllc1N5bSA9IGV4cG9ydHMucmVtb3ZlRW50aXR5U3ltID0gZXhwb3J0cy5jbGVhckVudGl0aWVzU3ltID0gZXhwb3J0cy5hZGRFbnRpdHlTeW0gPSB2b2lkIDA7XHJcbmV4cG9ydHMuYWRkRW50aXR5U3ltID0gU3ltYm9sKCk7XHJcbmV4cG9ydHMuY2xlYXJFbnRpdGllc1N5bSA9IFN5bWJvbCgpO1xyXG5leHBvcnRzLnJlbW92ZUVudGl0eVN5bSA9IFN5bWJvbCgpO1xyXG5leHBvcnRzLnNldEVudGl0aWVzU3ltID0gU3ltYm9sKCk7XHJcbmV4cG9ydHMuYWNjZXNzRGVzY1N5bSA9IFN5bWJvbCgpO1xyXG5leHBvcnRzLmV4aXN0ZW5jZURlc2NTeW0gPSBTeW1ib2woKTtcclxudmFyIEVBY2Nlc3M7XHJcbihmdW5jdGlvbiAoRUFjY2Vzcykge1xyXG4gICAgRUFjY2Vzc1tFQWNjZXNzW1wibWV0YVwiXSA9IDBdID0gXCJtZXRhXCI7XHJcbiAgICBFQWNjZXNzW0VBY2Nlc3NbXCJyZWFkXCJdID0gMV0gPSBcInJlYWRcIjtcclxuICAgIEVBY2Nlc3NbRUFjY2Vzc1tcIndyaXRlXCJdID0gMl0gPSBcIndyaXRlXCI7XHJcbn0pKEVBY2Nlc3MgPSBleHBvcnRzLkVBY2Nlc3MgfHwgKGV4cG9ydHMuRUFjY2VzcyA9IHt9KSk7XHJcbnZhciBFRXhpc3RlbmNlO1xyXG4oZnVuY3Rpb24gKEVFeGlzdGVuY2UpIHtcclxuICAgIEVFeGlzdGVuY2VbRUV4aXN0ZW5jZVtcInNldFwiXSA9IDBdID0gXCJzZXRcIjtcclxuICAgIEVFeGlzdGVuY2VbRUV4aXN0ZW5jZVtcInVuc2V0XCJdID0gMV0gPSBcInVuc2V0XCI7XHJcbn0pKEVFeGlzdGVuY2UgPSBleHBvcnRzLkVFeGlzdGVuY2UgfHwgKGV4cG9ydHMuRUV4aXN0ZW5jZSA9IHt9KSk7XHJcbnZhciBFVGFyZ2V0VHlwZTtcclxuKGZ1bmN0aW9uIChFVGFyZ2V0VHlwZSkge1xyXG4gICAgRVRhcmdldFR5cGVbRVRhcmdldFR5cGVbXCJjb21wb25lbnRcIl0gPSAwXSA9IFwiY29tcG9uZW50XCI7XHJcbiAgICBFVGFyZ2V0VHlwZVtFVGFyZ2V0VHlwZVtcImVudGl0eVwiXSA9IDFdID0gXCJlbnRpdHlcIjtcclxuICAgIEVUYXJnZXRUeXBlW0VUYXJnZXRUeXBlW1widGFnXCJdID0gMl0gPSBcInRhZ1wiO1xyXG59KShFVGFyZ2V0VHlwZSA9IGV4cG9ydHMuRVRhcmdldFR5cGUgfHwgKGV4cG9ydHMuRVRhcmdldFR5cGUgPSB7fSkpO1xyXG4vKlxyXG5leHBvcnQgaW50ZXJmYWNlIElRdWVyeTxEIGV4dGVuZHMgSUFjY2Vzc1F1ZXJ5UmVzdWx0PE9iamVjdD4gfCBURXhpc3RlbmNlUXVlcnlSZXN1bHQ+IHtcclxuICAgIGl0ZXIoKTogSXRlcmFibGVJdGVyYXRvcjxEIGV4dGVuZHMgQXJyYXk8aW5mZXIgVD4gPyBJRW50aXR5IDogeyBbUCBpbiBrZXlvZiBEXTogUmVxdWlyZWQ8T21pdDxJbnN0YW5jZVR5cGU8RFtQXT4sIGtleW9mIElBY2Nlc3NEZXNjcmlwdG9yPE9iamVjdD4+PiB9PlxyXG4gICAgbWF0Y2hlc0VudGl0eShlbnRpdHk6IElFbnRpdHkpOiBib29sZWFuXHJcbn1cclxuXHJcbmV4cG9ydCB0eXBlIFRRdWVyeVByb3RvPEQgZXh0ZW5kcyBJQWNjZXNzUXVlcnlSZXN1bHQ8T2JqZWN0PiB8IFRFeGlzdGVuY2VRdWVyeVJlc3VsdD4gPSB7IG5ldygpOiBJUXVlcnk8RD4gfTtcclxuKi8gXHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXF1ZXJ5LnNwZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5nZXREZWZhdWx0RGVzZXJpYWxpemVyID0gZXhwb3J0cy5nZXREZWZhdWx0U2VyaWFsaXplciA9IHZvaWQgMDtcclxuY29uc3QgZ2V0RGVmYXVsdFNlcmlhbGl6ZXIgPSBmdW5jdGlvbiAoY3VzdG9tU2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIChjb21wb25lbnQpID0+IHtcclxuICAgICAgICBsZXQgY29tcG9uZW50TmFtZSA9IHR5cGVvZiBjb21wb25lbnQ7XHJcbiAgICAgICAgc3dpdGNoICh0eXBlb2YgY29tcG9uZW50KSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBjb21wb25lbnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKGNvbXBvbmVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdudWxsJztcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNvbXBvbmVudE5hbWUgPSBjb21wb25lbnQuY29uc3RydWN0b3IubmFtZTtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdEYXRlJzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbXBvbmVudC5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnQXJyYXknOlxyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ09iamVjdCc6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb21wb25lbnQudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnTWFwJzpcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdTZXQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoQXJyYXkuZnJvbShjb21wb25lbnQpKTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlICdOdW1iZXInOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcG9uZW50O1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSBcInN0cmluZ1wiOiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoY29tcG9uZW50KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWN1c3RvbVNlcmlhbGl6ZXIpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBNaXNzaW5nIHNlcmlhbGl6ZXIgZm9yIFwiJHtjb21wb25lbnROYW1lfVwiIWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VzdG9tU2VyaWFsaXplcihjb21wb25lbnQpO1xyXG4gICAgfTtcclxufTtcclxuZXhwb3J0cy5nZXREZWZhdWx0U2VyaWFsaXplciA9IGdldERlZmF1bHRTZXJpYWxpemVyO1xyXG5jb25zdCBnZXREZWZhdWx0RGVzZXJpYWxpemVyID0gZnVuY3Rpb24gKGN1c3RvbURlc2VyaWFsaXplcikge1xyXG4gICAgcmV0dXJuIChjb25zdHJ1Y3Rvck5hbWUsIGRhdGEpID0+IHtcclxuICAgICAgICBzd2l0Y2ggKGNvbnN0cnVjdG9yTmFtZS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICAgICAgICAgIGNhc2UgJ2FycmF5Jzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVzZXJpYWxpemUgQXJyYXkgd2l0aCBkYXRhIG9mIHR5cGUgJHt0eXBlb2YgZGF0YX0hIEFycmF5IGV4cGVjdGVkIWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnZGF0ZSc6IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlc2VyaWFsaXplIERhdGUgd2l0aCBkYXRhIG9mIHR5cGUgJHt0eXBlb2YgZGF0YX0hIE51bWJlciBleHBlY3RlZCFgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShkYXRhKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdtYXAnOiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXNlcmlhbGl6ZSBNYXAgd2l0aCBkYXRhIG9mIHR5cGUgJHt0eXBlb2YgZGF0YX0hIEFycmF5IG9mIGFycmF5cyBleHBlY3RlZCFgKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgTWFwKGRhdGEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNhc2UgJ251bWJlcic6IHtcclxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPSAnbnVtYmVyJykge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGRlc2VyaWFsaXplIE51bWJlciB3aXRoIGRhdGEgb2YgdHlwZSAke3R5cGVvZiBkYXRhfSEgTnVtYmVyIGV4cGVjdGVkIWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnb2JqZWN0Jzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVzZXJpYWxpemUgT2JqZWN0IHdpdGggZGF0YSBvZiB0eXBlICR7dHlwZW9mIGRhdGF9ISBPYmplY3QgZXhwZWN0ZWQhYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXNlICdzZXQnOiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGF0YSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBkZXNlcmlhbGl6ZSBTZXQgd2l0aCBkYXRhIG9mIHR5cGUgJHt0eXBlb2YgZGF0YX0hIEFycmF5IGV4cGVjdGVkIWApO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTZXQoZGF0YSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2FzZSAnc3RyaW5nJzoge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVzZXJpYWxpemUgU3RyaW5nIHdpdGggZGF0YSBvZiB0eXBlICR7dHlwZW9mIGRhdGF9ISBTdHJpbmcgZXhwZWN0ZWQhYCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZGF0YTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWN1c3RvbURlc2VyaWFsaXplcikge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE1pc3NpbmcgZGVzZXJpYWxpemVyIGZvciBcIiR7Y29uc3RydWN0b3JOYW1lfVwiIWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gY3VzdG9tRGVzZXJpYWxpemVyKGNvbnN0cnVjdG9yTmFtZSwgZGF0YSk7XHJcbiAgICB9O1xyXG59O1xyXG5leHBvcnRzLmdldERlZmF1bHREZXNlcmlhbGl6ZXIgPSBnZXREZWZhdWx0RGVzZXJpYWxpemVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kZWZhdWx0LWhhbmRsZXJzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2VyRGUgPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbmNvbnN0IHNlcmRlX3NwZWNfMSA9IHJlcXVpcmUoXCIuL3NlcmRlLnNwZWNcIik7XHJcbmNvbnN0IHNlcmlhbF9mb3JtYXRfMSA9IHJlcXVpcmUoXCIuL3NlcmlhbC1mb3JtYXRcIik7XHJcbmNvbnN0IGRlZmF1bHRfaGFuZGxlcnNfMSA9IHJlcXVpcmUoXCIuL2RlZmF1bHQtaGFuZGxlcnNcIik7XHJcbmNvbnN0IGVudGl0eV8xID0gcmVxdWlyZShcIi4uL2VudGl0eVwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2VyZGUuc3BlY1wiKSwgZXhwb3J0cyk7XHJcbmNsYXNzIFNlckRlIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMudHlwZUhhbmRsZXJzID0gbmV3IE1hcCgpO1xyXG4gICAgfVxyXG4gICAgZGVzZXJpYWxpemUoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB1c2VEZWZhdWx0SGFuZGxlcjogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVzZURlZmF1bHRIYW5kbGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlLFxyXG4gICAgICAgICAgICB1c2VSZWdpc3RlcmVkSGFuZGxlcnM6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51c2VSZWdpc3RlcmVkSGFuZGxlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXHJcbiAgICAgICAgICAgIGZhbGxiYWNrSGFuZGxlcjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrSGFuZGxlcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IGVudGl0aWVzID0gW107XHJcbiAgICAgICAgbGV0IGVudGl0eTtcclxuICAgICAgICBsZXQgc2VyaWFsQ29tcG9uZW50RGF0YTtcclxuICAgICAgICBsZXQgc2VyaWFsQ29tcG9uZW50TmFtZTtcclxuICAgICAgICBsZXQgc2VyaWFsRW50aXR5O1xyXG4gICAgICAgIGxldCB0YWc7XHJcbiAgICAgICAgZm9yIChzZXJpYWxFbnRpdHkgb2YgZGF0YSkge1xyXG4gICAgICAgICAgICBlbnRpdHkgPSBuZXcgZW50aXR5XzEuRW50aXR5KCk7XHJcbiAgICAgICAgICAgIGZvciAoW3NlcmlhbENvbXBvbmVudE5hbWUsIHNlcmlhbENvbXBvbmVudERhdGFdIG9mIE9iamVjdC5lbnRyaWVzKHNlcmlhbEVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaW5hbE9wdGlvbnMudXNlUmVnaXN0ZXJlZEhhbmRsZXJzICYmIHRoaXMudHlwZUhhbmRsZXJzLmhhcyhzZXJpYWxDb21wb25lbnROYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5hZGRDb21wb25lbnQodGhpcy50eXBlSGFuZGxlcnMuZ2V0KHNlcmlhbENvbXBvbmVudE5hbWUpLmRlc2VyaWFsaXplcihzZXJpYWxDb21wb25lbnREYXRhKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzZXJpYWxDb21wb25lbnROYW1lID09IHNlcmRlX3NwZWNfMS5DVGFnTWFya2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHNlcmlhbENvbXBvbmVudERhdGEpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYXJyYXkgb2YgdGFncyBmb3IgdGhlIGhhc2ggaWRlbnRpZmllciEnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh0YWcgb2Ygc2VyaWFsQ29tcG9uZW50RGF0YSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIVsnc3RyaW5nJywgJ251bWJlciddLmluY2x1ZGVzKHR5cGVvZiB0YWcpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RhZ3MgbXVzdCBiZSBvZiB0eXBlIHN0cmluZyBvciBudW1iZXIhJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZW50aXR5LmFkZFRhZyh0YWcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpbmFsT3B0aW9ucy51c2VEZWZhdWx0SGFuZGxlcikge1xyXG4gICAgICAgICAgICAgICAgICAgIGVudGl0eS5hZGRDb21wb25lbnQoZGVmYXVsdF9oYW5kbGVyc18xLmdldERlZmF1bHREZXNlcmlhbGl6ZXIoZmluYWxPcHRpb25zLmZhbGxiYWNrSGFuZGxlcikoc2VyaWFsQ29tcG9uZW50TmFtZSwgc2VyaWFsQ29tcG9uZW50RGF0YSkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVudGl0aWVzLnB1c2goZW50aXR5KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZW50aXRpZXM6IGVudGl0aWVzLnZhbHVlcygpLFxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBnZXRSZWdpc3RlcmVkVHlwZUhhbmRsZXJzKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVIYW5kbGVycy5lbnRyaWVzKCk7XHJcbiAgICB9XHJcbiAgICByZWdpc3RlclR5cGVIYW5kbGVyKFR5cGUsIGRlc2VyaWFsaXplciwgc2VyaWFsaXplcikge1xyXG4gICAgICAgIGlmICh0aGlzLnR5cGVIYW5kbGVycy5oYXMoVHlwZS5uYW1lKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSB0eXBlIFwiJHtUeXBlLm5hbWV9XCIgd2FzIGFscmVhZHkgcmVnaXN0ZXJlZCFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy50eXBlSGFuZGxlcnMuc2V0KFR5cGUubmFtZSwge1xyXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZXIsXHJcbiAgICAgICAgICAgIHNlcmlhbGl6ZXIsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBzZXJpYWxpemUoZGF0YSwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2I7XHJcbiAgICAgICAgY29uc3QgZmluYWxPcHRpb25zID0ge1xyXG4gICAgICAgICAgICB1c2VEZWZhdWx0SGFuZGxlcjogKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLnVzZURlZmF1bHRIYW5kbGVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB0cnVlLFxyXG4gICAgICAgICAgICB1c2VSZWdpc3RlcmVkSGFuZGxlcnM6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy51c2VSZWdpc3RlcmVkSGFuZGxlcnMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHRydWUsXHJcbiAgICAgICAgICAgIGZhbGxiYWNrSGFuZGxlcjogb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZhbGxiYWNrSGFuZGxlcixcclxuICAgICAgICB9O1xyXG4gICAgICAgIGNvbnN0IG91dERhdGEgPSBuZXcgc2VyaWFsX2Zvcm1hdF8xLlNlcmlhbEZvcm1hdCgpO1xyXG4gICAgICAgIGxldCBjb21wb25lbnQ7XHJcbiAgICAgICAgbGV0IGVudGl0eTtcclxuICAgICAgICBsZXQgc2VyaWFsRGF0YTtcclxuICAgICAgICBsZXQgc2VyaWFsRW50aXR5O1xyXG4gICAgICAgIGxldCB0YWdzO1xyXG4gICAgICAgIGZvciAoZW50aXR5IG9mIGRhdGEuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgc2VyaWFsRW50aXR5ID0ge307XHJcbiAgICAgICAgICAgIGZvciAoY29tcG9uZW50IG9mIGVudGl0eS5nZXRDb21wb25lbnRzKCkpIHtcclxuICAgICAgICAgICAgICAgIGlmIChmaW5hbE9wdGlvbnMudXNlUmVnaXN0ZXJlZEhhbmRsZXJzICYmIHRoaXMudHlwZUhhbmRsZXJzLmhhcyhjb21wb25lbnQuY29uc3RydWN0b3IubmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxEYXRhID0gdGhpcy50eXBlSGFuZGxlcnMuZ2V0KGNvbXBvbmVudC5jb25zdHJ1Y3Rvci5uYW1lKS5zZXJpYWxpemVyKGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmaW5hbE9wdGlvbnMudXNlRGVmYXVsdEhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBzZXJpYWxEYXRhID0gZGVmYXVsdF9oYW5kbGVyc18xLmdldERlZmF1bHRTZXJpYWxpemVyKGZpbmFsT3B0aW9ucy5mYWxsYmFja0hhbmRsZXIpKGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBzZXJpYWxFbnRpdHlbY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWVdID0gc2VyaWFsRGF0YTtcclxuICAgICAgICAgICAgICAgIHNlcmlhbERhdGEgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgdGFncyA9IEFycmF5LmZyb20oZW50aXR5LmdldFRhZ3MoKSk7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFncy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VyaWFsRW50aXR5W3NlcmRlX3NwZWNfMS5DVGFnTWFya2VyXSA9IHRhZ3M7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3V0RGF0YS5wdXNoKHNlcmlhbEVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXREYXRhO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VyRGUgPSBTZXJEZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2VyZGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5DVGFnTWFya2VyID0gdm9pZCAwO1xyXG5leHBvcnRzLkNUYWdNYXJrZXIgPSAnI1RhZ3MnO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJkZS5zcGVjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuU2VyaWFsRm9ybWF0ID0gdm9pZCAwO1xyXG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zZXJpYWwtZm9ybWF0LnNwZWNcIiksIGV4cG9ydHMpO1xyXG5jbGFzcyBTZXJpYWxGb3JtYXQgZXh0ZW5kcyBBcnJheSB7XHJcbiAgICBzdGF0aWMgZnJvbUFycmF5KGFycikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VyaWFsRm9ybWF0KCkuZnJvbUFycmF5KGFycik7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIHJldHVybiBuZXcgU2VyaWFsRm9ybWF0KCkuZnJvbUpTT04oanNvbik7XHJcbiAgICB9XHJcbiAgICBmcm9tQXJyYXkoYXJyKSB7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbih0aGlzLCBhcnIpO1xyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgZnJvbUpTT04oanNvbikge1xyXG4gICAgICAgIHRoaXMubGVuZ3RoID0gMDtcclxuICAgICAgICBjb25zdCBuZXdWYWxzID0gSlNPTi5wYXJzZShqc29uKTtcclxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobmV3VmFscykpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnB1dCBKU09OIG11c3QgYmUgYW4gYXJyYXkhJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoY29uc3QgZW50aXR5IG9mIG5ld1ZhbHMpIHtcclxuICAgICAgICAgICAgdGhpcy5wdXNoKGVudGl0eSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdG9KU09OKGluZGVudGF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KEFycmF5LmZyb20odGhpcyksIHVuZGVmaW5lZCwgaW5kZW50YXRpb24pO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMuU2VyaWFsRm9ybWF0ID0gU2VyaWFsRm9ybWF0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zZXJpYWwtZm9ybWF0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNlcmlhbC1mb3JtYXQuc3BlYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG5leHBvcnRzLlN0YXRlID0gdm9pZCAwO1xyXG5jb25zdCB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdGF0ZS5zcGVjXCIpLCBleHBvcnRzKTtcclxuY2xhc3MgU3RhdGUge1xyXG4gICAgY29uc3RydWN0b3IoX3N5c3RlbXMgPSBbXSkge1xyXG4gICAgICAgIHRoaXMuX3N5c3RlbXMgPSBfc3lzdGVtcztcclxuICAgIH1cclxuICAgIGdldCBzeXN0ZW1zKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zeXN0ZW1zO1xyXG4gICAgfVxyXG4gICAgYWN0aXZhdGUoYWN0aW9ucykgeyB9XHJcbiAgICBjcmVhdGUoYWN0aW9ucykgeyB9XHJcbiAgICBkZWFjdGl2YXRlKGFjdGlvbnMpIHsgfVxyXG4gICAgZGVzdHJveShhY3Rpb25zKSB7IH1cclxufVxyXG5leHBvcnRzLlN0YXRlID0gU3RhdGU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0YXRlLnNwZWMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5TeXN0ZW0gPSB2b2lkIDA7XHJcbmNvbnN0IHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3N5c3RlbS5zcGVjXCIpLCBleHBvcnRzKTtcclxuY2xhc3MgU3lzdGVtIHtcclxuICAgIGRlc3Ryb3koYWN0aW9ucykgeyB9XHJcbiAgICBzZXR1cChhY3Rpb25zKSB7IH1cclxufVxyXG5leHBvcnRzLlN5c3RlbSA9IFN5c3RlbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3lzdGVtLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN5c3RlbS5zcGVjLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuXyA9IGV4cG9ydHMuV29ybGRCdWlsZGVyID0gdm9pZCAwO1xyXG5jb25zdCB3b3JsZF8xID0gcmVxdWlyZShcIi4vd29ybGRcIik7XHJcbmNvbnN0IHNlcmRlXzEgPSByZXF1aXJlKFwiLi9zZXJkZS9zZXJkZVwiKTtcclxuY2xhc3MgV29ybGRCdWlsZGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKGVjcykge1xyXG4gICAgICAgIHRoaXMuZWNzID0gZWNzO1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMuc2VyZGUgPSBuZXcgc2VyZGVfMS5TZXJEZSgpO1xyXG4gICAgICAgIHRoaXMuc3lzdGVtSW5mb3MgPSBuZXcgTWFwKCk7XHJcbiAgICB9XHJcbiAgICBhZGRDYWxsYmFjayhjYikge1xyXG4gICAgICAgIHRoaXMuY2FsbGJhY2tzLmFkZChjYik7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICBidWlsZCgpIHtcclxuICAgICAgICBjb25zdCB3b3JsZCA9IG5ldyB3b3JsZF8xLldvcmxkKHRoaXMuZWNzLCBuZXcgU2V0KHRoaXMuc3lzdGVtSW5mb3MudmFsdWVzKCkpLCB0aGlzLnNlcmRlKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGNiIG9mIHRoaXMuY2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGNiKHdvcmxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHdvcmxkO1xyXG4gICAgfVxyXG4gICAgd2l0aFN5c3RlbShTeXN0ZW0sIGRlcGVuZGVuY2llcykge1xyXG4gICAgICAgIGlmICh0aGlzLnN5c3RlbUluZm9zLmhhcyhTeXN0ZW0pKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlIHN5c3RlbSAke1N5c3RlbS5jb25zdHJ1Y3Rvci5uYW1lfSBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQhYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc3lzdGVtSW5mb3Muc2V0KFN5c3RlbSwge1xyXG4gICAgICAgICAgICBzeXN0ZW06IG5ldyBTeXN0ZW0oKSxcclxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBuZXcgU2V0KGRlcGVuZGVuY2llcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9XHJcbiAgICB3aXRoQ29tcG9uZW50KENvbXBvbmVudCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcclxuICAgICAgICB0aGlzLnNlcmRlLnJlZ2lzdGVyVHlwZUhhbmRsZXIoQ29tcG9uZW50LCAoX2IgPSAoX2EgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VyRGUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5kZXNlcmlhbGl6ZXIpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRhdGFTdHJ1Y3REZXNlcmlhbGl6ZXIuYmluZCh1bmRlZmluZWQsIENvbXBvbmVudCksIChfZCA9IChfYyA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zZXJEZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLnNlcmlhbGl6ZXIpICE9PSBudWxsICYmIF9kICE9PSB2b2lkIDAgPyBfZCA6IGRhdGFTdHJ1Y3RTZXJpYWxpemVyKTtcclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxuICAgIHdpdGhDb21wb25lbnRzKC4uLkNvbXBvbmVudHMpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IENvbXBvbmVudCBvZiBDb21wb25lbnRzKSB7XHJcbiAgICAgICAgICAgIHRoaXMud2l0aENvbXBvbmVudChDb21wb25lbnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcztcclxuICAgIH1cclxufVxyXG5leHBvcnRzLldvcmxkQnVpbGRlciA9IFdvcmxkQnVpbGRlcjtcclxuLy8gdG9kbzogcmVhZCB0aGUgQ29uc3RydWN0b3IgcGFyYW1ldGVycyBpbiBvcmRlciB0byB0aHJvdyBlYXJseSBpZiBhIGZpZWxkIGlzIG1pc3NpbmdcclxuZnVuY3Rpb24gZGF0YVN0cnVjdERlc2VyaWFsaXplcihDb25zdHJ1Y3RvciwgZGF0YSkge1xyXG4gICAgaWYgKHR5cGVvZiBkYXRhICE9ICdvYmplY3QnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgZGVmYXVsdC1kZXNlcmlhbGl6ZSAke0NvbnN0cnVjdG9yLm5hbWV9LCBiZWNhdXNlIHRoZSBkYXRhIGlzIG9mIHR5cGUgJHt0eXBlb2YgZGF0YX0hYCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBvYmogPSBuZXcgQ29uc3RydWN0b3IoKTtcclxuICAgIGZvciAoY29uc3Qga3Ygb2YgT2JqZWN0LmVudHJpZXMoZGF0YSkpIHtcclxuICAgICAgICBvYmpba3ZbMF1dID0ga3ZbMV07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG59XHJcbmZ1bmN0aW9uIGRhdGFTdHJ1Y3RTZXJpYWxpemVyKGNvbXBvbmVudCkge1xyXG4gICAgcmV0dXJuIGNvbXBvbmVudDtcclxufVxyXG5leHBvcnRzLl8gPSB7XHJcbiAgICBkYXRhU3RydWN0RGVzZXJpYWxpemVyLFxyXG4gICAgZGF0YVN0cnVjdFNlcmlhbGl6ZXIsXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmxkLWJ1aWxkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZXhwb3J0cy5Xb3JsZCA9IHZvaWQgMDtcclxuY29uc3QgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxuY29uc3QgZW50aXR5XzEgPSByZXF1aXJlKFwiLi9lbnRpdHlcIik7XHJcbmNvbnN0IGVudGl0eV9idWlsZGVyXzEgPSByZXF1aXJlKFwiLi9lbnRpdHktYnVpbGRlclwiKTtcclxuY29uc3Qgc3RhdGVfMSA9IHJlcXVpcmUoXCIuL3N0YXRlXCIpO1xyXG5jb25zdCBwZGFfMSA9IHJlcXVpcmUoXCIuL3BkYVwiKTtcclxuY29uc3Qgc2VyZGVfMSA9IHJlcXVpcmUoXCIuL3NlcmRlL3NlcmRlXCIpO1xyXG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIi4vY29tbWFuZHMvY29tbWFuZHNcIik7XHJcbmNvbnN0IGNvbW1hbmRzX2FnZ3JlZ2F0b3JfMSA9IHJlcXVpcmUoXCIuL2NvbW1hbmRzL2NvbW1hbmRzLWFnZ3JlZ2F0b3JcIik7XHJcbmNvbnN0IHF1ZXJ5XzEgPSByZXF1aXJlKFwiLi9xdWVyeVwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd29ybGQuc3BlY1wiKSwgZXhwb3J0cyk7XHJcbmNsYXNzIFdvcmxkIHtcclxuICAgIGNvbnN0cnVjdG9yKGVjcywgc3lzdGVtSW5mb3MgPSBuZXcgU2V0KCksIF9zZXJkZSA9IG5ldyBzZXJkZV8xLlNlckRlKCkpIHtcclxuICAgICAgICB0aGlzLmVjcyA9IGVjcztcclxuICAgICAgICB0aGlzLnN5c3RlbUluZm9zID0gc3lzdGVtSW5mb3M7XHJcbiAgICAgICAgdGhpcy5fc2VyZGUgPSBfc2VyZGU7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSBmYWxzZTtcclxuICAgICAgICB0aGlzLmVudGl0aWVzID0gbmV3IFNldCgpO1xyXG4gICAgICAgIHRoaXMucGRhID0gbmV3IHBkYV8xLlB1c2hEb3duQXV0b21hdG9uKCk7XHJcbiAgICAgICAgdGhpcy5ncm91cHMgPSB7XHJcbiAgICAgICAgICAgIG5leHRIYW5kbGU6IDAsXHJcbiAgICAgICAgICAgIGVudGl0eUxpbmtzOiBuZXcgTWFwKCksXHJcbiAgICAgICAgfTtcclxuICAgICAgICB0aGlzLnF1ZXJpZXMgPSBbXTtcclxuICAgICAgICB0aGlzLnJlc291cmNlcyA9IG5ldyBNYXAoKTtcclxuICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvblBpcGVsaW5lID0gW107XHJcbiAgICAgICAgdGhpcy5ydW5FeGVjdXRpb25QaXBlbGluZUNhY2hlID0gbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMucnVuUHJvbWlzZSA9IHVuZGVmaW5lZDtcclxuICAgICAgICB0aGlzLnNob3VsZFJ1blN5c3RlbXMgPSBmYWxzZTtcclxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcclxuICAgICAgICB0aGlzLl9jb21tYW5kc0FnZ3JlZ2F0b3IgPSBuZXcgY29tbWFuZHNfYWdncmVnYXRvcl8xLkNvbW1hbmRzQWdncmVnYXRvcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9jb21tYW5kcyA9IG5ldyBjb21tYW5kc18xLkNvbW1hbmRzKHRoaXMsIHRoaXMuX2NvbW1hbmRzQWdncmVnYXRvcik7XHJcbiAgICAgICAgdGhpcy5zeXN0ZW1Xb3JsZCA9IE9iamVjdC5mcmVlemUoe1xyXG4gICAgICAgICAgICBnZXQgY29tbWFuZHMoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5fY29tbWFuZHM7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldCBjdXJyZW50U3RhdGUoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5wZGEuc3RhdGU7XHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGdldEVudGl0aWVzOiB0aGlzLmdldEVudGl0aWVzLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIGdldFJlc291cmNlOiB0aGlzLmdldFJlc291cmNlLmJpbmQodGhpcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy50cmFuc2l0aW9uV29ybGQgPSBPYmplY3QuZnJlZXplKHtcclxuICAgICAgICAgICAgZ2V0IGNvbW1hbmRzKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuX2NvbW1hbmRzO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgY3VycmVudFN0YXRlKCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYucGRhLnN0YXRlO1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBnZXQgc2VyZGUoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VsZi5zZXJkZTtcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgYnVpbGRFbnRpdHk6IHRoaXMuYnVpbGRFbnRpdHkuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgZmx1c2hDb21tYW5kczogdGhpcy5mbHVzaENvbW1hbmRzLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIGdldEVudGl0aWVzOiB0aGlzLmdldEVudGl0aWVzLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIGdldFJlc291cmNlOiB0aGlzLmdldFJlc291cmNlLmJpbmQodGhpcyksXHJcbiAgICAgICAgICAgIGdldFJlc291cmNlczogdGhpcy5nZXRSZXNvdXJjZXMuYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgbWFpbnRhaW46IHRoaXMubWFpbnRhaW4uYmluZCh0aGlzKSxcclxuICAgICAgICAgICAgc2F2ZTogdGhpcy5zYXZlLmJpbmQodGhpcyksXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5zb3J0ZWRTeXN0ZW1zID0gdGhpcy5zb3J0U3lzdGVtcyh0aGlzLnN5c3RlbUluZm9zKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN5c3RlbUluZm8gb2YgdGhpcy5zeXN0ZW1JbmZvcykge1xyXG4gICAgICAgICAgICBpZiAoc3lzdGVtSW5mby5zeXN0ZW0ucXVlcnkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMucXVlcmllcy5wdXNoKHN5c3RlbUluZm8uc3lzdGVtLnF1ZXJ5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGdldCBjb21tYW5kcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fY29tbWFuZHM7XHJcbiAgICB9XHJcbiAgICBnZXQgZGlydHkoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcnR5O1xyXG4gICAgfVxyXG4gICAgZ2V0IHJ1bm5pbmcoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hvdWxkUnVuU3lzdGVtcztcclxuICAgIH1cclxuICAgIGdldCBzZXJkZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fc2VyZGU7XHJcbiAgICB9XHJcbiAgICBhZGRFbnRpdHkoZW50aXR5KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmVudGl0aWVzLmhhcyhlbnRpdHkpKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZW50aXRpZXMuYWRkKGVudGl0eSk7XHJcbiAgICAgICAgICAgIHRoaXMuX2RpcnR5ID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBhZGRSZXNvdXJjZShvYmosIC4uLmFyZ3MpIHtcclxuICAgICAgICBsZXQgdHlwZTtcclxuICAgICAgICBsZXQgaW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBvYmouY29uc3RydWN0b3I7XHJcbiAgICAgICAgICAgIGluc3RhbmNlID0gb2JqO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdHlwZSA9IG9iajtcclxuICAgICAgICAgICAgaW5zdGFuY2UgPSBuZXcgKG9iai5wcm90b3R5cGUuY29uc3RydWN0b3IuYmluZChvYmosIC4uLkFycmF5LmZyb20oYXJndW1lbnRzKS5zbGljZSgxKSkpKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLnJlc291cmNlcy5oYXModHlwZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZXNvdXJjZSB3aXRoIG5hbWUgXCIke3R5cGUubmFtZX1cIiBhbHJlYWR5IGV4aXN0cyFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5yZXNvdXJjZXMuc2V0KHR5cGUsIGluc3RhbmNlKTtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9XHJcbiAgICBidWlsZEVudGl0eSgpIHtcclxuICAgICAgICByZXR1cm4gbmV3IGVudGl0eV9idWlsZGVyXzEuRW50aXR5QnVpbGRlcigpO1xyXG4gICAgfVxyXG4gICAgY2xlYXJFbnRpdGllcygpIHtcclxuICAgICAgICB0aGlzLmVudGl0aWVzLmNsZWFyKCk7XHJcbiAgICB9XHJcbiAgICBjcmVhdGVFbnRpdHkoKSB7XHJcbiAgICAgICAgY29uc3QgZW50aXR5ID0gbmV3IGVudGl0eV8xLkVudGl0eSgpO1xyXG4gICAgICAgIHRoaXMuZW50aXRpZXMuYWRkKGVudGl0eSk7XHJcbiAgICAgICAgdGhpcy5fZGlydHkgPSB0cnVlO1xyXG4gICAgICAgIHJldHVybiBlbnRpdHk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBkaXNwYXRjaChzdGF0ZSkge1xyXG4gICAgICAgIGF3YWl0IHRoaXMucnVuKHtcclxuICAgICAgICAgICAgaW5pdGlhbFN0YXRlOiBzdGF0ZSxcclxuICAgICAgICAgICAgYWZ0ZXJTdGVwSGFuZGxlcjogYWN0aW9ucyA9PiBhY3Rpb25zLmNvbW1hbmRzLnN0b3BSdW4oKSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGZsdXNoQ29tbWFuZHMoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbW1hbmRzQWdncmVnYXRvci5leGVjdXRlQWxsKCk7XHJcbiAgICB9XHJcbiAgICBnZXRFbnRpdGllcyhxdWVyeSkge1xyXG4gICAgICAgIGlmICghcXVlcnkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW50aXRpZXMua2V5cygpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCByZXN1bHRFbnRpdGllcyA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgZW50aXR5O1xyXG4gICAgICAgIGZvciAoZW50aXR5IG9mIHRoaXMuZW50aXRpZXMua2V5cygpKSB7XHJcbiAgICAgICAgICAgIGlmIChxdWVyeS5tYXRjaGVzRW50aXR5KGVudGl0eSkpIHtcclxuICAgICAgICAgICAgICAgIHJlc3VsdEVudGl0aWVzLmFkZChlbnRpdHkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXN1bHRFbnRpdGllcy52YWx1ZXMoKTtcclxuICAgIH1cclxuICAgIGdldFJlc291cmNlKHR5cGUpIHtcclxuICAgICAgICBpZiAoIXRoaXMucmVzb3VyY2VzLmhhcyh0eXBlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlc291cmNlIG9mIHR5cGUgXCIke3R5cGUubmFtZX1cIiBkb2VzIG5vdCBleGlzdCFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzb3VyY2VzLmdldCh0eXBlKTtcclxuICAgIH1cclxuICAgIGdldFJlc291cmNlcygpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5yZXNvdXJjZXMudmFsdWVzKCk7XHJcbiAgICB9XHJcbiAgICBsb2FkKHByZWZhYiwgb3B0aW9ucywgaW50b0dyb3VwKSB7XHJcbiAgICAgICAgY29uc3QgZW50aXRpZXMgPSBbXTtcclxuICAgICAgICBjb25zdCBncm91cEhhbmRsZSA9IGludG9Hcm91cCAhPT0gbnVsbCAmJiBpbnRvR3JvdXAgIT09IHZvaWQgMCA/IGludG9Hcm91cCA6IHRoaXMuZ3JvdXBzLm5leHRIYW5kbGUrKztcclxuICAgICAgICBsZXQgZW50aXR5O1xyXG4gICAgICAgIGZvciAoZW50aXR5IG9mIHRoaXMuX3NlcmRlLmRlc2VyaWFsaXplKHByZWZhYiwgb3B0aW9ucykuZW50aXRpZXMpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyb3Vwcy5lbnRpdHlMaW5rcy5zZXQoZ3JvdXBIYW5kbGUsIGVudGl0aWVzKTtcclxuICAgICAgICByZXR1cm4gZ3JvdXBIYW5kbGU7XHJcbiAgICB9XHJcbiAgICAvLyB0b2RvOiBhZGQgcGFyYW1ldGVyIHdoaWNoIG9ubHkgbWFpbnRhaW5zIGZvciBhIHNwZWNpZmljIHN0YXRlXHJcbiAgICAvLyB0b2RvOiBtYXliZSB1c2UgYSBjaGFuZ2UtbG9nIHRvIG9ubHkgbWFpbnRhaW4gcmVhbCBjaGFuZ2VzIGluc3RlYWQgb2YgZXZlcnl0aGluZ1xyXG4gICAgbWFpbnRhaW4oKSB7XHJcbiAgICAgICAgbGV0IHF1ZXJ5O1xyXG4gICAgICAgIGZvciAocXVlcnkgb2YgdGhpcy5xdWVyaWVzKSB7XHJcbiAgICAgICAgICAgIHF1ZXJ5W3F1ZXJ5XzEuc2V0RW50aXRpZXNTeW1dKHRoaXMuZW50aXRpZXMudmFsdWVzKCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbWVyZ2UoZWxzZXdoZXJlLCBpbnRvR3JvdXApIHtcclxuICAgICAgICBjb25zdCBncm91cEhhbmRsZSA9IGludG9Hcm91cCAhPT0gbnVsbCAmJiBpbnRvR3JvdXAgIT09IHZvaWQgMCA/IGludG9Hcm91cCA6IHRoaXMuZ3JvdXBzLm5leHRIYW5kbGUrKztcclxuICAgICAgICBjb25zdCBlbnRpdGllcyA9IFtdO1xyXG4gICAgICAgIGxldCBlbnRpdHk7XHJcbiAgICAgICAgZm9yIChlbnRpdHkgb2YgZWxzZXdoZXJlLmdldEVudGl0aWVzKCkpIHtcclxuICAgICAgICAgICAgdGhpcy5hZGRFbnRpdHkoZW50aXR5KTtcclxuICAgICAgICAgICAgZW50aXRpZXMucHVzaChlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gW2dyb3VwSGFuZGxlLCBlbnRpdGllc107XHJcbiAgICB9XHJcbiAgICBhc3luYyBwb3BTdGF0ZSgpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnBkYS5wb3AoKSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlYWN0aXZhdGUodGhpcy50cmFuc2l0aW9uV29ybGQpKTtcclxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMucGRhLnN0YXRlO1xyXG4gICAgICAgIGlmICghbmV3U3RhdGUpIHtcclxuICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb25QaXBlbGluZSA9IFtdO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGF3YWl0IG5ld1N0YXRlLmFjdGl2YXRlKHRoaXMudHJhbnNpdGlvbldvcmxkKTtcclxuICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvblBpcGVsaW5lID0gKF9iID0gdGhpcy5ydW5FeGVjdXRpb25QaXBlbGluZUNhY2hlLmdldChuZXdTdGF0ZS5jb25zdHJ1Y3RvcikpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IFtdO1xyXG4gICAgfVxyXG4gICAgLy8gdG9kbzogaW1wcm92ZSBsb2dpYyB3aGljaCBzZXRzIHVwIHRoZSBncm91cHMgKHRyYWNrZWQgYnkgIzEzKVxyXG4gICAgcHJlcGFyZUV4ZWN1dGlvblBpcGVsaW5lKHN0YXRlKSB7XHJcbiAgICAgICAgLy8gdG9kbzogdGhpcyBjb3VsZCBiZSBmdXJ0aGVyIG9wdGltaXplZCBieSBhbGxvd2luZyBzeXN0ZW1zIHdpdGggZGVwZW5kZW5jaWVzIHRvIHJ1biBpbiBwYXJhbGxlbFxyXG4gICAgICAgIC8vICAgIGlmIGFsbCBvZiB0aGVpciBkZXBlbmRlbmNpZXMgYWxyZWFkeSByYW5cclxuICAgICAgICAvLyB0b2RvOiBhbHNvLCBpZiB0d28gc3lzdGVtcyBkZXBlbmQgb24gdGhlIHNhbWUgY29tcG9uZW50cywgdGhleSBtYXkgcnVuIGluIHBhcmFsbGVsXHJcbiAgICAgICAgLy8gICAgaWYgdGhleSBvbmx5IHJlcXVpcmUgUkVBRCBhY2Nlc3NcclxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcclxuICAgICAgICBjb25zdCBzdGF0ZVN5c3RlbXMgPSBzdGF0ZS5zeXN0ZW1zO1xyXG4gICAgICAgIGxldCBleGVjdXRpb25Hcm91cCA9IG5ldyBTZXQoKTtcclxuICAgICAgICBsZXQgc2hvdWxkUnVuU3lzdGVtO1xyXG4gICAgICAgIGxldCBzeXN0ZW1JbmZvO1xyXG4gICAgICAgIGlmICh0aGlzLnNvcnRlZFN5c3RlbXMuc2l6ZSA9PSAwKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc29ydFN5c3RlbXModGhpcy5zeXN0ZW1JbmZvcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZvciAoc3lzdGVtSW5mbyBvZiB0aGlzLnNvcnRlZFN5c3RlbXMpIHtcclxuICAgICAgICAgICAgc2hvdWxkUnVuU3lzdGVtID0gISFzdGF0ZVN5c3RlbXMuZmluZChzdGF0ZVN5cyA9PiBzdGF0ZVN5cy5wcm90b3R5cGUuY29uc3RydWN0b3IubmFtZSA9PT0gc3lzdGVtSW5mby5zeXN0ZW0uY29uc3RydWN0b3IubmFtZSk7XHJcbiAgICAgICAgICAgIGlmIChzaG91bGRSdW5TeXN0ZW0pIHtcclxuICAgICAgICAgICAgICAgIGlmIChzeXN0ZW1JbmZvLmRlcGVuZGVuY2llcy5zaXplID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGV4ZWN1dGlvbkdyb3VwKTtcclxuICAgICAgICAgICAgICAgICAgICBleGVjdXRpb25Hcm91cCA9IG5ldyBTZXQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGV4ZWN1dGlvbkdyb3VwLmFkZChzeXN0ZW1JbmZvLnN5c3RlbSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmVzdWx0LnB1c2goZXhlY3V0aW9uR3JvdXApO1xyXG4gICAgICAgIHJldHVybiByZXN1bHQ7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwdXNoU3RhdGUoTmV3U3RhdGUpIHtcclxuICAgICAgICB2YXIgX2EsIF9iO1xyXG4gICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnBkYS5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlYWN0aXZhdGUodGhpcy50cmFuc2l0aW9uV29ybGQpKTtcclxuICAgICAgICB0aGlzLnBkYS5wdXNoKE5ld1N0YXRlKTtcclxuICAgICAgICBjb25zdCBuZXdTdGF0ZSA9IHRoaXMucGRhLnN0YXRlO1xyXG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRTeXN0ZW1OYW1lcyA9IEFycmF5LmZyb20odGhpcy5zeXN0ZW1JbmZvcykubWFwKG5mbyA9PiBuZm8uc3lzdGVtLmNvbnN0cnVjdG9yLm5hbWUpO1xyXG4gICAgICAgIGZvciAoY29uc3Qgc3lzdGVtIG9mIG5ld1N0YXRlLnN5c3RlbXMpIHtcclxuICAgICAgICAgICAgaWYgKCFyZWdpc3RlcmVkU3lzdGVtTmFtZXMuaW5jbHVkZXMoc3lzdGVtLm5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW5ub3QgaW5mZXIgZGVwZW5kZW5jaWVzLCBzbyB3ZSBoYXZlIHRvIHRocm93IDovXHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYERpZCB5b3UgZm9yZ2V0IHRvIHJlZ2lzdGVyIFN5c3RlbSAke3N5c3RlbS5uYW1lfT9gKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5ydW5FeGVjdXRpb25QaXBlbGluZUNhY2hlLmhhcyhOZXdTdGF0ZSkpIHtcclxuICAgICAgICAgICAgdGhpcy5ydW5FeGVjdXRpb25QaXBlbGluZSA9IChfYiA9IHRoaXMucnVuRXhlY3V0aW9uUGlwZWxpbmVDYWNoZS5nZXQoTmV3U3RhdGUpKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBbXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIG5ld1N0YXRlLmNyZWF0ZSh0aGlzLnRyYW5zaXRpb25Xb3JsZCk7XHJcbiAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uUGlwZWxpbmUgPSB0aGlzLnByZXBhcmVFeGVjdXRpb25QaXBlbGluZShuZXdTdGF0ZSk7XHJcbiAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uUGlwZWxpbmVDYWNoZS5zZXQoTmV3U3RhdGUsIHRoaXMucnVuRXhlY3V0aW9uUGlwZWxpbmUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBhd2FpdCBuZXdTdGF0ZS5hY3RpdmF0ZSh0aGlzLnRyYW5zaXRpb25Xb3JsZCk7XHJcbiAgICB9XHJcbiAgICBhc3luYyBwcmVwYXJlUnVuKGNvbmZpZ3VyYXRpb24pIHtcclxuICAgICAgICB2YXIgX2EsIF9iLCBfYztcclxuICAgICAgICBpZiAodGhpcy5ydW5Qcm9taXNlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGRpc3BhdGNoIGxvb3AgaXMgYWxyZWFkeSBydW5uaW5nIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZGlydHkpIHtcclxuICAgICAgICAgICAgdGhpcy5tYWludGFpbigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25maWd1cmF0aW9uIHx8IChjb25maWd1cmF0aW9uID0ge30pO1xyXG4gICAgICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IGNvbmZpZ3VyYXRpb24uaW5pdGlhbFN0YXRlXHJcbiAgICAgICAgICAgID8gY29uZmlndXJhdGlvbi5pbml0aWFsU3RhdGVcclxuICAgICAgICAgICAgOiBzdGF0ZV8xLlN0YXRlLmJpbmQodW5kZWZpbmVkLCBBcnJheS5mcm9tKHRoaXMuc3lzdGVtSW5mb3MudmFsdWVzKCkpLm1hcChzeXN0ZW1JbmZvID0+IHN5c3RlbUluZm8uc3lzdGVtLmNvbnN0cnVjdG9yKSk7XHJcbiAgICAgICAgY29uc3QgcnVuQ29uZmlnID0ge1xyXG4gICAgICAgICAgICBhZnRlclN0ZXBIYW5kbGVyOiAoX2EgPSBjb25maWd1cmF0aW9uLmFmdGVyU3RlcEhhbmRsZXIpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IChfYWN0aW9uID0+IHsgfSksXHJcbiAgICAgICAgICAgIGJlZm9yZVN0ZXBIYW5kbGVyOiAoX2IgPSBjb25maWd1cmF0aW9uLmJlZm9yZVN0ZXBIYW5kbGVyKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAoX2FjdGlvbiA9PiB7IH0pLFxyXG4gICAgICAgICAgICBleGVjdXRpb25GdW5jdGlvbjogKF9jID0gY29uZmlndXJhdGlvbi5leGVjdXRpb25GdW5jdGlvbikgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDogKHR5cGVvZiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPT0gJ2Z1bmN0aW9uJ1xyXG4gICAgICAgICAgICAgICAgPyByZXF1ZXN0QW5pbWF0aW9uRnJhbWVcclxuICAgICAgICAgICAgICAgIDogc2V0VGltZW91dCksXHJcbiAgICAgICAgICAgIGluaXRpYWxTdGF0ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHRoaXMucGRhLmNsZWFyKCk7XHJcbiAgICAgICAgdGhpcy5zaG91bGRSdW5TeXN0ZW1zID0gdHJ1ZTtcclxuICAgICAgICBmb3IgKGNvbnN0IHN5c3RlbUluZm8gb2YgdGhpcy5zeXN0ZW1JbmZvcykge1xyXG4gICAgICAgICAgICBhd2FpdCBzeXN0ZW1JbmZvLnN5c3RlbS5zZXR1cCh0aGlzLnN5c3RlbVdvcmxkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgYXdhaXQgdGhpcy5wdXNoU3RhdGUoaW5pdGlhbFN0YXRlKTtcclxuICAgICAgICB0aGlzLnJ1bkV4ZWN1dGlvblBpcGVsaW5lID0gdGhpcy5wcmVwYXJlRXhlY3V0aW9uUGlwZWxpbmUodGhpcy5wZGEuc3RhdGUpO1xyXG4gICAgICAgIHRoaXMubGFzdFJ1blByZXBhcmF0aW9uID0gcnVuQ29uZmlnO1xyXG4gICAgICAgIHJldHVybiBydW5Db25maWc7XHJcbiAgICB9XHJcbiAgICByZW1vdmVFbnRpdHkoZW50aXR5KSB7XHJcbiAgICAgICAgdGhpcy5lbnRpdGllcy5kZWxldGUoZW50aXR5KTtcclxuICAgICAgICB0aGlzLl9kaXJ0eSA9IHRydWU7XHJcbiAgICB9XHJcbiAgICByZW1vdmVFbnRpdHlGcm9tU3lzdGVtcyhlbnRpdHkpIHtcclxuICAgICAgICB0aGlzLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgIHRoaXMubWFpbnRhaW4oKTtcclxuICAgIH1cclxuICAgIHJlcGxhY2VFbnRpdGllc1dpdGgod29ybGQpIHtcclxuICAgICAgICB0aGlzLmNsZWFyRW50aXRpZXMoKTtcclxuICAgICAgICB0aGlzLm1lcmdlKHdvcmxkKTtcclxuICAgIH1cclxuICAgIHJlcGxhY2VSZXNvdXJjZShvYmosIC4uLmFyZ3MpIHtcclxuICAgICAgICBsZXQgdHlwZTtcclxuICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcclxuICAgICAgICAgICAgdHlwZSA9IG9iai5jb25zdHJ1Y3RvcjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHR5cGUgPSBvYmo7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5yZXNvdXJjZXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugd2l0aCBuYW1lIFwiJHt0eXBlLm5hbWV9XCIgZG9lcyBub3QgZXhpc3RzIWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc291cmNlcy5kZWxldGUodHlwZSk7XHJcbiAgICAgICAgdGhpcy5hZGRSZXNvdXJjZShvYmosIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gICAgcmVtb3ZlUmVzb3VyY2UodHlwZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5yZXNvdXJjZXMuaGFzKHR5cGUpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUmVzb3VyY2Ugd2l0aCBuYW1lIFwiJHt0eXBlLm5hbWV9XCIgZG9lcyBub3QgZXhpc3RzIWApO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnJlc291cmNlcy5kZWxldGUodHlwZSk7XHJcbiAgICB9XHJcbiAgICBydW4oY29uZmlndXJhdGlvbiwgc2tpcFByZXBhcmF0aW9uID0gZmFsc2UpIHtcclxuICAgICAgICBjb25zdCBydW5Qcm9taXNlID0gbmV3IFByb21pc2UoYXN5bmMgKHJlc29sdmVyKSA9PiB7XHJcbiAgICAgICAgICAgIGxldCBwcmVwYXJlZENvbmZpZztcclxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fY29tbWFuZHNBZ2dyZWdhdG9yLmV4ZWN1dGVBbGwoKTtcclxuICAgICAgICAgICAgaWYgKCFza2lwUHJlcGFyYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHByZXBhcmVkQ29uZmlnID0gYXdhaXQgdGhpcy5wcmVwYXJlUnVuKGNvbmZpZ3VyYXRpb24pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcHJlcGFyZWRDb25maWcgPSB0aGlzLmxhc3RSdW5QcmVwYXJhdGlvbjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXByZXBhcmVkQ29uZmlnKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBydW4gd2l0aG91dCBwcmVwYXJpbmcgdGhlIHJ1biEnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnJ1blByb21pc2UgPSBydW5Qcm9taXNlO1xyXG4gICAgICAgICAgICBjb25zdCBhZnRlclN0ZXBIYW5kbGVyID0gcHJlcGFyZWRDb25maWcuYWZ0ZXJTdGVwSGFuZGxlcjtcclxuICAgICAgICAgICAgY29uc3QgYmVmb3JlU3RlcEhhbmRsZXIgPSBwcmVwYXJlZENvbmZpZy5iZWZvcmVTdGVwSGFuZGxlcjtcclxuICAgICAgICAgICAgY29uc3QgZXhlY0ZuID0gcHJlcGFyZWRDb25maWcuZXhlY3V0aW9uRnVuY3Rpb247XHJcbiAgICAgICAgICAgIGxldCBzeXN0ZW1Qcm9taXNlcztcclxuICAgICAgICAgICAgY29uc3QgY2xlYW5VcCA9IGFzeW5jICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgICAgIGF3YWl0ICgoX2EgPSB0aGlzLnBkYS5zdGF0ZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmRlYWN0aXZhdGUodGhpcy50cmFuc2l0aW9uV29ybGQpKTtcclxuICAgICAgICAgICAgICAgIGZvciAobGV0IHN0YXRlID0gdGhpcy5wZGEucG9wKCk7ICEhc3RhdGU7IHN0YXRlID0gdGhpcy5wZGEucG9wKCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBhd2FpdCBzdGF0ZS5kZXN0cm95KHRoaXMudHJhbnNpdGlvbldvcmxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3lzdGVtSW5mbyBvZiB0aGlzLnN5c3RlbUluZm9zKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgc3lzdGVtSW5mby5zeXN0ZW0uZGVzdHJveSh0aGlzLnN5c3RlbVdvcmxkKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHRoaXMucnVuRXhlY3V0aW9uUGlwZWxpbmVDYWNoZS5jbGVhcigpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5ydW5Qcm9taXNlID0gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIoKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3QgbWFpbkxvb3AgPSBhc3luYyAoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuc2hvdWxkUnVuU3lzdGVtcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGF3YWl0IGNsZWFuVXAoKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBiZWZvcmVTdGVwSGFuZGxlcih0aGlzLnRyYW5zaXRpb25Xb3JsZCk7XHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgbGV0IGV4ZWN1dGlvbkdyb3VwO1xyXG4gICAgICAgICAgICAgICAgICAgIGxldCBzeXN0ZW07XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yIChleGVjdXRpb25Hcm91cCBvZiB0aGlzLnJ1bkV4ZWN1dGlvblBpcGVsaW5lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHN5c3RlbVByb21pc2VzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoc3lzdGVtIG9mIGV4ZWN1dGlvbkdyb3VwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzeXN0ZW1Qcm9taXNlcy5wdXNoKHN5c3RlbS5ydW4odGhpcy5zeXN0ZW1Xb3JsZCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IFByb21pc2UuYWxsKHN5c3RlbVByb21pc2VzKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBhd2FpdCBhZnRlclN0ZXBIYW5kbGVyKHRoaXMudHJhbnNpdGlvbldvcmxkKTtcclxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX2NvbW1hbmRzQWdncmVnYXRvci5leGVjdXRlQWxsKCk7XHJcbiAgICAgICAgICAgICAgICBleGVjRm4obWFpbkxvb3ApO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBleGVjRm4obWFpbkxvb3ApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJldHVybiBydW5Qcm9taXNlO1xyXG4gICAgfVxyXG4gICAgc29ydFN5c3RlbXModW5zb3J0ZWQpIHtcclxuICAgICAgICBjb25zdCB1bnNvcnRlZEFyciA9IEFycmF5LmZyb20odW5zb3J0ZWQpO1xyXG4gICAgICAgIGNvbnN0IGdyYXBoID0gbmV3IE1hcCh1bnNvcnRlZEFyci5tYXAobm9kZSA9PiBbbm9kZS5zeXN0ZW0uY29uc3RydWN0b3IsIEFycmF5LmZyb20obm9kZS5kZXBlbmRlbmNpZXMpXSkpO1xyXG4gICAgICAgIGxldCBlZGdlcztcclxuICAgICAgICAvLy8gdG9wb3NvcnQgd2l0aCBLYWhuXHJcbiAgICAgICAgLy8vIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1RvcG9sb2dpY2FsX3NvcnRpbmcjS2FobidzX2FsZ29yaXRobVxyXG4gICAgICAgIGNvbnN0IEwgPSBbXTsgLy8gRW1wdHkgbGlzdCB0aGF0IHdpbGwgY29udGFpbiB0aGUgc29ydGVkIGVsZW1lbnRzXHJcbiAgICAgICAgY29uc3QgUyA9IEFycmF5LmZyb20oZ3JhcGguZW50cmllcygpKS5maWx0ZXIocGFpciA9PiBwYWlyWzFdLmxlbmd0aCA9PT0gMCkubWFwKHBhaXIgPT4gcGFpclswXSk7IC8vIFNldCBvZiBhbGwgbm9kZXMgd2l0aCBubyBpbmNvbWluZyBlZGdlXHJcbiAgICAgICAgbGV0IG47XHJcbiAgICAgICAgLy8gd2hpbGUgUyBpcyBub24tZW1wdHkgZG9cclxuICAgICAgICB3aGlsZSAoUy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIHJlbW92ZSBhIG5vZGUgbiBmcm9tIFNcclxuICAgICAgICAgICAgbiA9IFMuc2hpZnQoKTtcclxuICAgICAgICAgICAgLy8gYWRkIG4gdG8gdGFpbCBvZiBMXHJcbiAgICAgICAgICAgIEwucHVzaChuKTtcclxuICAgICAgICAgICAgLy8gZm9yIGVhY2ggbm9kZSBtIHdpdGggYW4gZWRnZSBlIGZyb20gbiB0byBtIGRvXHJcbiAgICAgICAgICAgIGZvciAobGV0IG0gb2YgQXJyYXkuZnJvbShncmFwaC5lbnRyaWVzKCkpLmZpbHRlcihwYWlyID0+IHBhaXJbMV0uaW5jbHVkZXMobikpLm1hcChwYWlyID0+IHBhaXJbMF0pKSB7XHJcbiAgICAgICAgICAgICAgICAvLyByZW1vdmUgZWRnZSBlIGZyb20gdGhlIGdyYXBoXHJcbiAgICAgICAgICAgICAgICBlZGdlcyA9IGdyYXBoLmdldChtKTtcclxuICAgICAgICAgICAgICAgIGVkZ2VzLnNwbGljZShlZGdlcy5pbmRleE9mKG4pLCAxKTtcclxuICAgICAgICAgICAgICAgIC8vIGlmIG0gaGFzIG5vIG90aGVyIGluY29taW5nIGVkZ2VzIHRoZW5cclxuICAgICAgICAgICAgICAgIGlmIChlZGdlcy5sZW5ndGggPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGluc2VydCBtIGludG8gU1xyXG4gICAgICAgICAgICAgICAgICAgIFMucHVzaChtKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoQXJyYXkuZnJvbShncmFwaC52YWx1ZXMoKSkuZmluZChuID0+IG4ubGVuZ3RoID4gMCkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3lzdGVtIGRlcGVuZGVuY3kgZ3JhcGggaXMgY3ljbGljIScpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBsZXQgb2JqO1xyXG4gICAgICAgIHJldHVybiBuZXcgU2V0KEwubWFwKHQgPT4ge1xyXG4gICAgICAgICAgICBvYmogPSB1bnNvcnRlZEFyci5maW5kKG4gPT4gbi5zeXN0ZW0uY29uc3RydWN0b3IgPT0gdCk7XHJcbiAgICAgICAgICAgIGlmICghb2JqKSB7XHJcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFRoZSBzeXN0ZW0gJHt0Lm5hbWV9IHdhcyBub3QgcmVnaXN0ZXJlZCFgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gb2JqO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxuICAgIHN0b3BSdW4oKSB7XHJcbiAgICAgICAgdGhpcy5zaG91bGRSdW5TeXN0ZW1zID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBzYXZlKHF1ZXJ5LCBvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VyZGUuc2VyaWFsaXplKHsgZW50aXRpZXM6IHRoaXMuZ2V0RW50aXRpZXMocXVlcnkpIH0sIG9wdGlvbnMpO1xyXG4gICAgfVxyXG4gICAgdW5sb2FkUHJlZmFiKGhhbmRsZSkge1xyXG4gICAgICAgIGlmICghdGhpcy5ncm91cHMuZW50aXR5TGlua3MuaGFzKGhhbmRsZSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCBhbnkgbG9hZGVkIHByZWZhYiB1bmRlciBoYW5kbGUgXCIke2hhbmRsZX1cIiFgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbGV0IGVudGl0eTtcclxuICAgICAgICBmb3IgKGVudGl0eSBvZiB0aGlzLmdyb3Vwcy5lbnRpdHlMaW5rcy5nZXQoaGFuZGxlKSkge1xyXG4gICAgICAgICAgICB0aGlzLnJlbW92ZUVudGl0eShlbnRpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmdyb3Vwcy5lbnRpdHlMaW5rcy5kZWxldGUoaGFuZGxlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLldvcmxkID0gV29ybGQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmxkLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmxkLnNwZWMuanMubWFwIiwiLyohICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UgKi9cclxuXHJcbnZhciBleHRlbmRTdGF0aWNzID0gZnVuY3Rpb24oZCwgYikge1xyXG4gICAgZXh0ZW5kU3RhdGljcyA9IE9iamVjdC5zZXRQcm90b3R5cGVPZiB8fFxyXG4gICAgICAgICh7IF9fcHJvdG9fXzogW10gfSBpbnN0YW5jZW9mIEFycmF5ICYmIGZ1bmN0aW9uIChkLCBiKSB7IGQuX19wcm90b19fID0gYjsgfSkgfHxcclxuICAgICAgICBmdW5jdGlvbiAoZCwgYikgeyBmb3IgKHZhciBwIGluIGIpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYiwgcCkpIGRbcF0gPSBiW3BdOyB9O1xyXG4gICAgcmV0dXJuIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbn07XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19leHRlbmRzKGQsIGIpIHtcclxuICAgIGlmICh0eXBlb2YgYiAhPT0gXCJmdW5jdGlvblwiICYmIGIgIT09IG51bGwpXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNsYXNzIGV4dGVuZHMgdmFsdWUgXCIgKyBTdHJpbmcoYikgKyBcIiBpcyBub3QgYSBjb25zdHJ1Y3RvciBvciBudWxsXCIpO1xyXG4gICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgIGZ1bmN0aW9uIF9fKCkgeyB0aGlzLmNvbnN0cnVjdG9yID0gZDsgfVxyXG4gICAgZC5wcm90b3R5cGUgPSBiID09PSBudWxsID8gT2JqZWN0LmNyZWF0ZShiKSA6IChfXy5wcm90b3R5cGUgPSBiLnByb3RvdHlwZSwgbmV3IF9fKCkpO1xyXG59XHJcblxyXG5leHBvcnQgdmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYykge1xyXG4gICAgdmFyIGMgPSBhcmd1bWVudHMubGVuZ3RoLCByID0gYyA8IDMgPyB0YXJnZXQgOiBkZXNjID09PSBudWxsID8gZGVzYyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpIDogZGVzYywgZDtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICBlbHNlIGZvciAodmFyIGkgPSBkZWNvcmF0b3JzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSBpZiAoZCA9IGRlY29yYXRvcnNbaV0pIHIgPSAoYyA8IDMgPyBkKHIpIDogYyA+IDMgPyBkKHRhcmdldCwga2V5LCByKSA6IGQodGFyZ2V0LCBrZXkpKSB8fCByO1xyXG4gICAgcmV0dXJuIGMgPiAzICYmIHIgJiYgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCByKSwgcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fbWV0YWRhdGEobWV0YWRhdGFLZXksIG1ldGFkYXRhVmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5tZXRhZGF0YSA9PT0gXCJmdW5jdGlvblwiKSByZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCB2YXIgX19jcmVhdGVCaW5kaW5nID0gT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcclxufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcclxuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XHJcbiAgICBvW2syXSA9IG1ba107XHJcbn0pO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fZXhwb3J0U3RhcihtLCBvKSB7XHJcbiAgICBmb3IgKHZhciBwIGluIG0pIGlmIChwICE9PSBcImRlZmF1bHRcIiAmJiAhT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG8sIHApKSBfX2NyZWF0ZUJpbmRpbmcobywgbSwgcCk7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fcmVhZChvLCBuKSB7XHJcbiAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICBpZiAoIW0pIHJldHVybiBvO1xyXG4gICAgdmFyIGkgPSBtLmNhbGwobyksIHIsIGFyID0gW10sIGU7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdoaWxlICgobiA9PT0gdm9pZCAwIHx8IG4tLSA+IDApICYmICEociA9IGkubmV4dCgpKS5kb25lKSBhci5wdXNoKHIudmFsdWUpO1xyXG4gICAgfVxyXG4gICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICBmaW5hbGx5IHtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZmluYWxseSB7IGlmIChlKSB0aHJvdyBlLmVycm9yOyB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWQoKSB7XHJcbiAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICBhciA9IGFyLmNvbmNhdChfX3JlYWQoYXJndW1lbnRzW2ldKSk7XHJcbiAgICByZXR1cm4gYXI7XHJcbn1cclxuXHJcbi8qKiBAZGVwcmVjYXRlZCAqL1xyXG5leHBvcnQgZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fc3ByZWFkQXJyYXkodG8sIGZyb20sIHBhY2spIHtcclxuICAgIGlmIChwYWNrIHx8IGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIGZvciAodmFyIGkgPSAwLCBsID0gZnJvbS5sZW5ndGgsIGFyOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgaWYgKGFyIHx8ICEoaSBpbiBmcm9tKSkge1xyXG4gICAgICAgICAgICBpZiAoIWFyKSBhciA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20sIDAsIGkpO1xyXG4gICAgICAgICAgICBhcltpXSA9IGZyb21baV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRvLmNvbmNhdChhciB8fCBmcm9tKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fYXdhaXQodikge1xyXG4gICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jR2VuZXJhdG9yKHRoaXNBcmcsIF9hcmd1bWVudHMsIGdlbmVyYXRvcikge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBnID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pLCBpLCBxID0gW107XHJcbiAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHJlc3VtZShuLCB2KSB7IHRyeSB7IHN0ZXAoZ1tuXSh2KSk7IH0gY2F0Y2ggKGUpIHsgc2V0dGxlKHFbMF1bM10sIGUpOyB9IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAocikgeyByLnZhbHVlIGluc3RhbmNlb2YgX19hd2FpdCA/IFByb21pc2UucmVzb2x2ZShyLnZhbHVlLnYpLnRoZW4oZnVsZmlsbCwgcmVqZWN0KSA6IHNldHRsZShxWzBdWzJdLCByKTsgfVxyXG4gICAgZnVuY3Rpb24gZnVsZmlsbCh2YWx1ZSkgeyByZXN1bWUoXCJuZXh0XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gcmVqZWN0KHZhbHVlKSB7IHJlc3VtZShcInRocm93XCIsIHZhbHVlKTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2FzeW5jVmFsdWVzKG8pIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgbSA9IG9bU3ltYm9sLmFzeW5jSXRlcmF0b3JdLCBpO1xyXG4gICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiAobyA9IHR5cGVvZiBfX3ZhbHVlcyA9PT0gXCJmdW5jdGlvblwiID8gX192YWx1ZXMobykgOiBvW1N5bWJvbC5pdGVyYXRvcl0oKSwgaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIpLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGkpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlbbl0gPSBvW25dICYmIGZ1bmN0aW9uICh2KSB7IHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7IHYgPSBvW25dKHYpLCBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCB2LmRvbmUsIHYudmFsdWUpOyB9KTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgZCwgdikgeyBQcm9taXNlLnJlc29sdmUodikudGhlbihmdW5jdGlvbih2KSB7IHJlc29sdmUoeyB2YWx1ZTogdiwgZG9uZTogZCB9KTsgfSwgcmVqZWN0KTsgfVxyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19tYWtlVGVtcGxhdGVPYmplY3QoY29va2VkLCByYXcpIHtcclxuICAgIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNvb2tlZCwgXCJyYXdcIiwgeyB2YWx1ZTogcmF3IH0pOyB9IGVsc2UgeyBjb29rZWQucmF3ID0gcmF3OyB9XHJcbiAgICByZXR1cm4gY29va2VkO1xyXG59O1xyXG5cclxudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9IE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xyXG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcclxufTtcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBfX2ltcG9ydERlZmF1bHQobW9kKSB7XHJcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IGRlZmF1bHQ6IG1vZCB9O1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gX19jbGFzc1ByaXZhdGVGaWVsZEdldChyZWNlaXZlciwgc3RhdGUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHJlYWQgcHJpdmF0ZSBtZW1iZXIgZnJvbSBhbiBvYmplY3Qgd2hvc2UgY2xhc3MgZGlkIG5vdCBkZWNsYXJlIGl0XCIpO1xyXG4gICAgcmV0dXJuIGtpbmQgPT09IFwibVwiID8gZiA6IGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyKSA6IGYgPyBmLnZhbHVlIDogc3RhdGUuZ2V0KHJlY2VpdmVyKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==